#!/usr/bin/env bash

#========================================================================================================
#
#  Author:		Christian Zettel (ccztux)
#			2017-05-14
#			http://linuxinside.at
#
#  Copyright:		Copyright © 2017 Christian Zettel (ccztux), all rights reserved
#
#  Project website:	https://github.com/ccztux/modpd
#
#  Last Modification:	Christian Zettel (ccztux)
#			2017-10-03
#
#  Description:		modpd (Monitoring Obsessing Data Processor Daemon)
#
#  License:		GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#========================================================================================================


#--------------------------------
# Print error messages to stderr:
#--------------------------------

eprintf()
{
	printf "%b\\n" "${1}" >&2
}



#--------------
# Bash options:
#--------------

set -o noclobber || { printf "Setting essential bash option: 'noclobber' was not successful, terminating...\\n" ; exit 244 ; }
set -o nounset || { printf "Setting essential bash option: 'nounset' was not successful, terminating...\\n" ; exit 245 ; }
set -o pipefail || { printf "Setting essential bash option: 'pipefail' was not successful, terminating...\\n" ; exit 246 ; }



#-------
# Traps:
#-------

trap 'sigHandler SIGUSR1' SIGUSR1 || { printf "Setting essential trap for signal: 'SIGUSR1' was not successful, terminating...\\n" ; exit 247 ; }
trap 'sigHandler SIGTERM' SIGTERM || { printf "Setting essential trap for signal: 'SIGTERM' was not successful, terminating...\\n" ; exit 248 ; }
trap 'sigHandler SIGINT' SIGINT || { printf "Setting essential trap for signal: 'SIGINT' was not successful, terminating...\\n" ; exit 249 ; }
trap 'sigHandler SIGHUP' SIGHUP || { printf "Setting essential trap for signal: 'SIGHUP' was not successful, terminating...\\n" ; exit 250 ; }
trap 'sigHandler SIGABRT' SIGABRT || { printf "Setting essential trap for signal: 'SIGABRT' was not successful, terminating...\\n" ; exit 251 ; }
trap 'sigHandler SIGQUIT' SIGQUIT || { printf "Setting essential trap for signal: 'SIGQUIT' was not successful, terminating...\\n" ; exit 252 ; }
trap 'sigHandler ERR "${LINENO}" "${BASH_COMMAND}"' ERR || { printf "Setting essential trap for signal: 'ERR' was not successful, terminating...\\n" ; exit 253 ; }
trap 'sigHandler EXIT' EXIT || { printf "Setting essential trap for signal: 'EXIT' was not successful, terminating...\\n" ; exit 254 ; }






#-----------
# Functions:
#-----------

printUsage()
{
	setRequiredVariables

	printf "Usage: %s OPTIONS\\n\\n" "${script_name}"
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "OPTIONS:\\n"
	printf "   -h\\t\\tShows this help.\\n"
	printf "   -c\\t\\tConfig file. (If undefined default value: '%s' will be used.)\\n" "${script_config_file}"
	printf "   -l\\t\\tLock file. (If undefined default value: '%s' will be used.)\\n" "${script_lock_file}"
	printf "   -v\\t\\tShows detailed version information.\\n"
}

printScriptInfos()
{
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Project website:\\t%s\\n" "${script_project_website}"
	printf "License:\\t\\t%s\\n\\n" "${script_license}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "Copyright:\\t\\t%s\\n" "${script_copyright}"
}

printStatistic()
{
	logHandler "- Statistic data - ${script_name} is running: '${SECONDS}' seconds"
	logHandler "- Statistic data - Total processed jobs: '${script_job_counter_total}', successful processed jobs: '${script_job_counter_ok}', unsuccessful processed jobs: '${script_job_counter_nok}', timed out jobs: '${script_job_counter_timeout}'."
	logHandler "- Statistic data - Handled host checks: '${script_host_counter}', handled service checks: '${script_service_counter}', invalid datasets received: '${script_invalid_data_counter}'."
}

resetCounters()
{
	script_job_counter_total="0"
	script_job_counter_ok="0"
	script_job_counter_nok="0"
	script_job_counter_timeout="0"
	script_host_counter="0"
	script_service_counter="0"
	script_invalid_data_counter="0"
}

printStatisticWatchdog()
{
	local statistic_interval_helper="$((SECONDS + statistic_interval))"

	while true
	do
		if [ "${statistic_interval_helper}" -le "${SECONDS}" ]
		then
			# shellcheck disable=SC2154
			${kill_bin} -SIGUSR1 "${script_pid}"
			statistic_interval_helper="$((SECONDS + statistic_interval))"
		fi

		# shellcheck disable=SC2154
		${sleep_bin} 1
	done
}

printNagiosCheckData()
{
	local timestamp=

	if [ "${date_bin_printf:-}" == "1" ]
	then
		date_cmd="${date_bin:-} '%(${log_timestamp_format})T\\n'"
	else
		date_cmd="${date_bin:-} '+${log_timestamp_format}'"
	fi

	timestamp="$(eval "${date_cmd}")"

	printf "#!/usr/bin/env bash\\n\\n"
	printf "#========================================================================================================\\n"
	printf "#\\n"
	printf "#  Author:\\t\\t%s\\n" "${script_author}"
	printf "#\\t\\t\\t2017-05-14\\n"
	printf "#\\t\\t\\thttp://linuxinside.at\\n"
	printf "#\\n"
	printf "#  Copyright:\\t\\t%s\\n" "${script_copyright}"
	printf "#\\n"
	printf "#  Project website:\\t%s\\n" "${script_project_website}"
	printf "#\\n"
	printf "#  Last Modification:\\t%s\\n" "${script_author}"
	printf "#\\t\\t\\t%s\\n" "${script_last_modification_date}"
	printf "#\\n"
	printf "#  Description:\\t\\t%s\\n" "${script_description}"
	printf "#\\n"
	printf "#  License:\\t\\t%s\\n" "${script_license}"
	printf "#\\n"
	printf "#  This program is free software: you can redistribute it and/or modify\\n"
	printf "#  it under the terms of the GNU General Public License as published by\\n"
	printf "#  the Free Software Foundation, either version 3 of the License, or\\n"
	printf "#  (at your option) any later version.\\n"
	printf "#\\n"
	printf "#  This program is distributed in the hope that it will be useful,\\n"
	printf "#  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n"
	printf "#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n"
	printf "#  GNU General Public License for more details.\\n"
	printf "#\\n"
	printf "#  You should have received a copy of the GNU General Public License\\n"
	printf "#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n"
	printf "#\\n"
	printf "#\\n"
	printf "#  DONT DELETE THIS FILE, because its the database for check_modpd !!!\\n"
	printf "#\\n"
	printf "#  Generated by:\\t%s\\n" "${script_name}"
	printf "#\\n"
	printf "#  Generated at:\\t%s\\n" "${timestamp}"
	printf "#\\n"
	printf "#========================================================================================================\\n\\n"
	printf "# shellcheck disable=SC2034\\n\\n"
	printf "# shows how long %s is running in seconds\\n" "${script_name}"
	printf "%s_runtime=\"%s\"\\n\\n" "${script_name}" "${SECONDS}"
	printf "# shows how much nrdp or nsca jobs where handled in one statistic data period (%s seconds)\\n" "${statistic_interval}"
	printf "script_job_counter_total=\"%s\"\\n\\n" "${script_job_counter_total}"
	printf "# shows how much nrdp or nsca jobs where handled successfully in one statistic data period (%s seconds)\\n" "${statistic_interval}"
	printf "script_job_counter_ok=\"%s\"\\n\\n" "${script_job_counter_ok}"
	printf "# shows how much nrdp or nsca jobs where handled unsuccessfully in one statistic data period (%s seconds)\\n" "${statistic_interval}"
	printf "script_job_counter_nok=\"%s\"\\n\\n" "${script_job_counter_nok}"
	printf "# shows how much nrdp or nsca jobs timed out in one statistic data period (%s seconds)\\n" "${statistic_interval}"
	printf "script_job_counter_timeout=\"%s\"\\n\\n" "${script_job_counter_timeout}"
	printf "# shows how much host checks where handled in one statistic data period (%s seconds)\\n" "${statistic_interval}"
	printf "script_host_counter=\"%s\"\\n\\n" "${script_host_counter}"
	printf "# shows how much service checks where handled in one statistic data period (%s seconds)\\n" "${statistic_interval}"
	printf "script_service_counter=\"%s\"\\n\\n" "${script_service_counter}"
	printf "# shows how much invalid datasets where received in one statistic data period (%s seconds)\\n" "${statistic_interval}"
	printf "script_invalid_data_counter=\"%s\"\\n" "${script_invalid_data_counter}"
}

checkOptions()
{
	if [ -z "${script_config_file:-}" ]
	then
		printf "Missing option: -c\\n\\n"
		printUsage

		script_bypass_exit_routines="1"
		script_exit_code="30"

		exit
	fi

	if [ -z "${script_lock_file:-}" ]
	then
		printf "Missing option: -l\\n\\n"
		printUsage

		script_exit_code="31"
		script_bypass_exit_routines="1"

		exit
	fi
}

setRequiredVariables()
{
	local script_config_name=

	# define base path of modpd
	script_base_path="/usr/local/modpd"

	# path to lock directory
	script_lock_directory="${script_base_path}/var/lock"

	# path to libexec directory
	script_libexec_directory="${script_base_path}/libexec"

	# log directory
	script_log_directory="${script_base_path}/var/log/"

	if [ -n "${script_config_file:-}" ]
	then
		script_config_name="${script_config_file##*/}"
		script_config_name="${script_config_name//.conf/}"
		script_lock_file="${script_lock_directory}/${script_name}.${script_config_name}.lock"
		script_log_file="${script_log_directory}/${script_name}.${script_config_name}.log"
	fi
}

includeConfig()
{
	local rc=

	checkFilePermissions "${script_config_file}"
	rc="${?}"

	case "${rc}" in
		4|5|6|7)
			# shellcheck source=/scripts/usr/local/modpd/etc/modpd.conf
			source "${script_config_file}"
			rc="${?}"

			if [ "${rc}" == "0" ]
			then
				checkRequiredBinaries
			else
				printf "Including config file: '%s' was not successful, exiting.\\n" "${script_config_file}"
				script_exit_code="40"
				exit
			fi
			;;
		10)
			printf "Config file: '%s' does not exist, exiting.\\n" "${script_config_file}"
			script_exit_code="41"
			exit
			;;
		*)
			printf "Config file: '%s' exists, but it is not readable, exiting.\\n" "${script_config_file}"
			script_exit_code="42"
			exit
			;;
	esac
}

reloadConfig()
{
	local rc=

	if  [ -n "${script_statistic_watchdog_pid}" ]
	then
		${kill_bin} -s SIGTERM "${script_statistic_watchdog_pid}"
	fi

	includeConfig
	rc="${?}"

	printStatisticWatchdog &
	script_statistic_watchdog_pid="${!}"

	if [ "${rc}" == "0" ]
	then
		logHandlerSetConfig
		rc="${?}"

		if [ "${rc}" == "0" ]
		then
			setProxy
			rc="${?}"

			if [ "${rc}" == "0" ]
			then
				buildJobCommand
				rc="${?}"

				if [ "${rc}" == "0" ]
				then
					return 0
				else
					return 1
				fi
			else
				return 2
			fi
		else
			return 3
		fi
	else
		return 4
	fi
}

checkBin()
{
	local binary="${1:-}"
	local _bin=

	if _bin="$(command -v "${binary}" 2>/dev/null)"
	then
		export "${binary//-/_}"_bin="${_bin}"
		return 0
	else
		return 1
	fi
}

checkRequiredBinaries()
{
	local rc=
	local required_binaries=()
	local binaries_not_found=()
	local binaries_not_found_helper=

	if [ "${log_to_syslog}" == "1" ]
	then
		required_binaries+=("logger")
	fi

	if [ "${log_to_journal}" -eq "1" ]
	then
		required_binaries+=("systemd-cat")
	fi

	if [ "${log_to_file}" == "1" ] || [ "${log_to_stdout}" == "1" ]
	then
		if [ "${BASH_VERSINFO[0]}" -ge "4" ] && [ "${BASH_VERSINFO[1]}" -ge "2" ]
		then
			date_bin_printf="1"
			date_bin="printf"
		else
			required_binaries+=("date")
		fi
	fi

	if [ "${job_timeout_enabled}" == "1" ]
	then
		required_binaries+=("timeout")
	fi

	if [ "${obsessing_interface}" == "nrdp" ]
	then
		required_binaries+=("php")
	fi

	required_binaries+=("whoami" "pgrep" "rm" "mkdir" "mkfifo" "kill" "sleep")

	for bin in "${required_binaries[@]}"
	do
		if ! checkBin "${bin}"
		then
			binaries_not_found+=("${bin}")
		fi
	done

	logHandlerSetConfig
	logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"

	if [ "${#binaries_not_found[@]}" -gt "1" ]
	then
		binaries_not_found_helper="${binaries_not_found[*]}"
		binaries_not_found_helper="${binaries_not_found_helper//\ /\,\ }"

		logHandler "Required binaries: '${binaries_not_found_helper}' not found, exiting."
		script_exit_code="127"
		exit
	elif [ "${#binaries_not_found[@]}" -eq "1" ]
	then
		logHandler "Required binary: '${binaries_not_found[*]}' not found, exiting."
		script_exit_code="127"
		exit
	fi
}

calculateFunctionNameLength()
{
	local function=
	local function_names=()
	function_names_max_length="0"
	IFS=$'\n' read -d "" -r -a function_names <<< "$(declare -F)"

	for function in "${function_names[@]//declare -f /}"
	do
		if [ "${#function}" -gt "${function_names_max_length}" ]
		then
			function_names_max_length="${#function}"
		fi
	done
}

logHandlerSetConfig()
{
	log_conf="0"
	b_log_to_file="1"
	b_log_to_stdout="2"
	b_log_to_syslog="4"
	b_log_to_journal="8"
	b_date_bin_available="16"
	b_logger_bin_available="32"
	b_systemd_cat_bin_available="64"

	if [ "${date_bin_printf:-}" -eq "1" ]
	then
		date_cmd_format_prefix="'%("
		date_cmd_format_suffix=")T\\n' -1"
	else
		date_cmd_format_prefix="'+"
		date_cmd_format_suffix="'"
	fi

	if [ "${log_to_file}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_file ))"
	fi

	if [ "${log_to_stdout}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_stdout ))"
	fi

	if [ "${log_to_syslog}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_syslog ))"
	fi

	if [ "${log_to_journal}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_journal ))"
	fi

	if [ -n "${date_bin:-}" ]
	then
		log_conf="$(( log_conf | b_date_bin_available ))"
	fi

	if [ -n "${logger_bin:-}" ]
	then
		log_conf="$(( log_conf | b_logger_bin_available ))"
	fi

	if [ -n "${systemd_cat_bin:-}" ]
	then
		log_conf="$(( log_conf | b_systemd_cat_bin_available ))"
	fi
}

logHandlerStdinHelper()
{
	while read -r
	do
		logHandler "${REPLY}"
	done < "/dev/stdin"
}

logHandler()
{
	local log_message="${1:-}"
	local log_timestamp=
	local calling_function=
	local log_secure_replace_string="[HIDDEN FOR SECURITY]"

	if [ -z "${log_message:-}" ]
	then
		if [ ! -t "0" ]
		then
			logHandlerStdinHelper
		fi
	else
		log_message="${log_message//\`/}"
		log_message="${log_message//${proxy_password:-}/${log_secure_replace_string}}"
		log_message="${log_message//${nrdp_password:-}/${log_secure_replace_string}}"
		log_message="${log_message//${nrdp_token:-}/${log_secure_replace_string}}"

		if [ "${script_log_requirements_ok}" -ne "1" ]
		then
			eprintf "${log_message}"
			return
		fi

		if [ "${FUNCNAME[1]}" != "logHandlerStdinHelper" ]
		then
			calling_function="${FUNCNAME[1]}"
		else
			calling_function="${FUNCNAME[3]}"
		fi

		if [ "$(( log_conf & b_log_to_stdout ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_date_bin_available ))" -gt "0" ]
			then
				if [ -z "${log_timestamp}" ]
				then
					log_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${log_timestamp_format}${date_cmd_format_suffix}")"
				fi

				printf "%s | %6d | %*s | %s\\n" "${log_timestamp}" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}"
			else
				printf "[Date bin not found] | %6d | %*s | %s\\n" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_file ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_date_bin_available ))" -gt "0" ]
			then
				if [ -z "${log_timestamp}" ]
				then
					log_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${log_timestamp_format}${date_cmd_format_suffix}")"
				fi

				printf "%s | %6d | %*s | %s\\n" "${log_timestamp}" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}" >>"${script_log_file}"
			else
				printf "[Date bin not found] | %6d | %*s | %s\\n" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}" >>"${script_log_file}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_syslog ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_logger_bin_available ))" -gt "0" ]
			then
				${logger_bin} -t "${script_name}[${script_pid}]" -- "(${calling_function}) ${log_message}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_journal ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_systemd_cat_bin_available ))" -gt "0" ]
			then
				printf "(%s) %s\\n" "${calling_function}" "${log_message}" | ${systemd_cat_bin} --identifier="${script_name}"
			fi
		fi
	fi
}

sigHandler()
{
	local signal="${1:-}"
	local bash_lineno="${2:-}"
	local bash_command="${3:-}"
	local rc=

	case "${signal}" in
		SIGUSR1)
			if [ "${statistic_enabled}" == "1" ]
			then
				printStatistic
			fi

			resetCounters
			;;
		SIGTERM)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="143"
			exit
			;;
		SIGINT)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="130"
			exit
			;;
		SIGHUP)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for config reload..."
			fi

			reloadConfig
			rc="${?}"

			if [ "${rc}" == "0" ]
			then
				logHandler "Config reload was successful."
			else
				logHandler "Config reload was not successful."
			fi
			;;
		SIGABRT)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="134"
			exit
			;;
		SIGQUIT)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi


			script_exit_code="129"
			exit
			;;
		ERR)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', at line number: '${bash_lineno}', command: '${bash_command}'."
			fi

			script_exit_code="1"
			exit
			;;
		EXIT)
			printStatistic

			logHandler "Caught: '${signal}', exiting script..."

			if [ "${script_bypass_exit_routines}" != "1" ]
			then
				if [ "${script_another_instance_is_running}" != "1" ]
				then
					checkNamedPipe
					rc="${?}"

					if [ "${rc}" == "0" ]
					then
						removeNamedPipe
					fi

					checkLock
					rc="${?}"

					if [ "${rc}" == "0" ]
					then
						removeLock
					fi
				fi
			else
				logHandler "We hope you are informed better now. :P This was a lazy job. :)"
			fi

			logHandler "Exitcode: '${script_exit_code}'."
			logHandler "${script_name} was running: '${SECONDS}' seconds."
			logHandler "Bye, bye..."

			if [ -n "${kill_bin:-}" ]
			then
				if [ "${signal}" != "EXIT" ]
				then
					${kill_bin} -s "${signal}" -- -"${script_pid}"
				else
					script_shutdown_in_progress="1"
					${kill_bin} -s SIGTERM -- -"${script_pid}"
				fi
			fi

			exit ${script_exit_code}
			;;
		*)
			logHandler "Caught: '${signal}' in function: '${FUNCNAME[0]}', but dont know what to do with it..."
			return 1
			;;
	esac
}

checkLock()
{
	local rc=

	logHandler "Check if lock file: '${script_lock_file}' exists and if it is read/writeable..."

	checkFilePermissions "${script_lock_file}"
	rc="${?}"

	case "${rc}" in
		6|7)
			logHandler "Lock file exists and it is read/writeable."
			return 0
			;;
		10)
			logHandler "Lock file doesnt exist."
			return 1
			;;
		*)
			logHandler "Lock file exists, but it is not read/writeable."
			return 2
			;;
	esac
}

setLock()
{
	local rc=

	logHandler "Check if script lock directory: '${script_lock_directory}' exists and permissions to set lock are ok..."

	checkDirectoryPermissions "${script_lock_directory}"
	rc="${?}"

	case "${rc}" in
		3|7)
			logHandler "Script lock directory exists and permissions are ok."
			;;
		10)
			logHandler "Script lock directory doesnt exist."
			logHandler "Creating script lock directory..."

			# shellcheck disable=SC2154
			${mkdir_bin} -p "${script_lock_directory}" 2>&1 | logHandler
			rc="${PIPESTATUS[0]}"

			if [ "${rc}" == "0" ]
			then
				logHandler "Creating script lock directory was successful."
			else
				logHandler "Creating script lock directory was not successful, exiting."
				script_exit_code="50"
				exit
			fi
			;;
		*)
			logHandler "Script lock directory exists, but permissions are not ok, exiting."
			script_exit_code="51"
			exit
			;;
	esac

	logHandler "Setting lock..."

	printf "%s\\n" "${script_pid}" > "${script_lock_file}"
	rc="${?}"

	if [ "${rc}" == "0" ]
	then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful. Maybe another instance has set the lock between checking lock and setting lock."
		script_exit_code="52"
		exit
	fi
}

removeLock()
{
	local rc=

	logHandler "Removing lock..."

	# shellcheck disable=SC2154
	${rm_bin} "${script_lock_file}" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"

	if [ "${rc}" == "0" ]
	then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="60"
		exit
	fi
}

setProxy()
{
	if [ "${proxy_enabled}" == "1" ]
	then
		local proxy=
		local proxy_url=

		logHandler "Using proxy is enabled, building proxy configuration..."

		if [ -n "${proxy_port}" ]
		then
			proxy_url="${proxy_ip}:${proxy_port}"
		else
			proxy_url="${proxy_ip}"
		fi

		if [ -n "${proxy_username}" ] && [ -n "${proxy_password}" ]
		then
			proxy="${proxy_protocol}://${proxy_username}:${proxy_password}@${proxy_url}"
		else
			proxy="${proxy_protocol}://${proxy_url}"
		fi

		export http_proxy="${proxy}"
		export https_proxy="${proxy}"
		export ftp_proxy="${proxy}"
		export socks_proxy="${proxy}"
		export HTTP_PROXY="${proxy}"
		export HTTPS_PROXY="${proxy}"
		export FTP_PROXY="${proxy}"
		export SOCKS_PROXY="${proxy}"

		logHandler "We build the following proxy config: '${proxy}'."
	fi
}

checkNamedPipeExists()
{
	local file="${1:-}"

	if [ -p "${file}" ]
	then
		return 0
	else
		return 1
	fi
}

checkNamedPipePermissions()
{
	# file doesnt exist:	rc=10
	# read allowed:		rc=4|5|6|7
	# write allowed:	rc=2|3|6|7
	# execute allowed:	rc=1|3|5|7
	# read/write allowed:	rc=6|7

	local file="${1:-}"
	local rc=
	local file_permission=

	checkNamedPipeExists "${file}"
	rc="${?}"

	if [ "${rc}" == "0" ]
	then
		if [ -x "${file}" ]
		then
			file_permission="$((file_permission + 2#0001))"
		fi

		if [ -w "${file}" ]
		then
			file_permission="$((file_permission + 2#0010))"
		fi

		if [ -r "${file}" ]
		then
			file_permission="$((file_permission + 2#0100))"
		fi
	else
		file_permission="$((2#1010))"
	fi

	return "${file_permission}"
}

checkRegularFileExists()
{
	local file="${1:-}"

	if [ -f "${file}" ]
	then
		return 0
	else
		return 1
	fi
}

checkFilePermissions()
{
	# file doesnt exist:	rc=10
	# read allowed:		rc=4|5|6|7
	# write allowed:	rc=2|3|6|7
	# execute allowed:	rc=1|3|5|7
	# read/write allowed:	rc=6|7

	local file="${1:-}"
	local rc=
	local file_permission=

	checkRegularFileExists "${file}"
	rc="${?}"

	if [ "${rc}" == "0" ]
	then
		if [ -x "${file}" ]
		then
			file_permission="$((file_permission + 2#0001))"
		fi

		if [ -w "${file}" ]
		then
			file_permission="$((file_permission + 2#0010))"
		fi

		if [ -r "${file}" ]
		then
			file_permission="$((file_permission + 2#0100))"
		fi
	else
		file_permission="$((2#1010))"
	fi

	return "${file_permission}"
}

checkDirectoryExists()
{
	local directory="${1:-}"

	if [ -d "${directory}" ]
	then
		return 0
	else
		return 1
	fi
}

checkDirectoryPermissions()
{
	# directory doesnt exist:	rc=10
	# read allowed:			rc=4|5|6|7
	# write allowed:		rc=2|3|6|7
	# execute allowed:		rc=1|3|5|7

	local directory="${1:-}"
	local rc=
	local directory_permission=

	checkDirectoryExists "${directory}"
	rc="${?}"

	if [ "${rc}" == "0" ]
	then
		if [ -x "${directory}" ]
		then
			directory_permission="$((directory_permission + 2#0001))"
		fi

		if [ -w "${directory}" ]
		then
			directory_permission="$((directory_permission + 2#0010))"
		fi

		if [ -r "${directory}" ]
		then
			directory_permission="$((directory_permission + 2#0100))"
		fi
	else
		directory_permission="$((2#1010))"
	fi

	return "${directory_permission}"
}

checkBashVersion()
{
	logHandler "Checking bash version..."

	if [ -z "${BASH_VERSINFO[0]}" ]
	then
		logHandler "Could not determine bash version, exiting."
		script_exit_code="70"
		exit
	else
		if [ "${BASH_VERSINFO[0]}" -lt "${script_minimal_required_bash_version}" ]
		then
			logHandler "Bash version: '${BASH_VERSINFO[0]}' doesnt meet requirements, terminating."

			script_bypass_exit_routines="1"
			script_exit_code="71"
			exit
		else
			logHandler "Bash version: '${BASH_VERSINFO[0]}' meets requirements."
		fi
	fi
}

getUser()
{
	local script_exec_user=

	logHandler "Get user which starts the script..."

	if [ -n "${SUDO_USER:-}" ]
	then
		script_exec_user="$SUDO_USER"
	else
		# shellcheck disable=SC2154
		script_exec_user="$(${whoami_bin})"
	fi

	logHandler "${script_name} was started as user: '${script_exec_user}'."
}

checkAlreadyRunningInstance()
{
	local rc=
	local session_pids=()
	local running_script_pids=()

	# shellcheck disable=SC2154
	# shellcheck disable=SC2207
	session_pids+=($(${pgrep_bin} -d " " -s "${script_pid}"))
	session_pids+=("${script_pid}")
	# shellcheck disable=SC2154
	# shellcheck disable=SC2207
	running_script_pids+=($(${pgrep_bin} -d " " -f "^(.*)bash(.*)${script_base_path}/bin/${script_name}(.*)$"))

	for running_pid in "${!running_script_pids[@]}"
	do
	   	for session_pid in "${!session_pids[@]}"
		do
			if [ "${running_script_pids[$running_pid]}" == "${session_pids[$session_pid]}" ]
			then
				unset "running_script_pids[$running_pid]"
				break
			fi
		done
	done

	logHandler "Check if another instance of: '${script_name}' is already running..."

	checkLock
	rc="${?}"

	if [ "${rc}" != "0" ] && [ -z "${running_script_pids[*]:-}" ]
	then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif [ "${rc}" == "0" ] && [ -z "${running_script_pids[*]:-}" ]
	then
		logHandler "No other instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."
		logHandler "We try to remove the old, leftover lockfile..."

		removeLock
	elif [ "${rc}" == "0" ] && [ -n "${running_script_pids[*]:-}" ]
	then
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids[*]}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="80"
		exit
	elif [ "${rc}" != "0" ] && [ -n "${running_script_pids[*]:-}" ]
	then
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids[*]}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="81"
		exit
	fi
}

createNamedPipe()
{
	local rc=

	checkNamedPipe
	rc="${?}"

	if [ "${rc}" == "1" ]
	then
		logHandler "Creating named pipe..."

		# shellcheck disable=SC2154
		${mkfifo_bin} "${named_pipe_filename}" 2>&1 | logHandler
		rc="${PIPESTATUS[0]}"

		if [ "${rc}" == "0" ]
		then
			logHandler "Creating named pipe was successful."
		else
			logHandler "Creating named pipe was not successful, exiting."
			script_exit_code="90"
			exit
		fi
	fi

	exec 3<> "${named_pipe_filename}"
}

removeNamedPipe()
{
	local rc=

	logHandler "Remove named pipe..."

	# shellcheck disable=SC2154
	${rm_bin} "${named_pipe_filename}" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"

	if [ "${rc}" == "0" ]
	then
		logHandler "Removing named pipe was successful."

		exec 3>&-
		exec 3<&-
	else
		logHandler "Removing named pipe was not successful, exiting."
		script_exit_code="100"
		exit
	fi
}

checkNamedPipe()
{
	local rc=

	logHandler "Check if named pipe: '${named_pipe_filename}' exists and if it is read/writeable..."

	checkNamedPipePermissions "${named_pipe_filename}"
	rc="${?}"

	case "${rc}" in
		6|7)
			logHandler "Named pipe exists and it is read/writeable."
			return 0
			;;
		10)
			logHandler "Named pipe doesnt exist."
			return 1
			;;
		*)
			logHandler "Named pipe exists, but it is not read/writeable, exiting."
			script_exit_code="110"
			exit
			;;
	esac
}

buildJobCommand()
{
	logHandler "Building job command..."

	if [ "${job_timeout_enabled}" == "1" ]
	then
		# shellcheck disable=SC2154
		job_command="${timeout_bin} --signal=TERM ${job_timeout}"
	fi

	case "${obsessing_interface:-}" in
		nrdp)
			if [ -n "${nrdp_username}" ] && [ -n "${nrdp_password}" ]
			then
				# shellcheck disable=SC2154
				job_command="${job_command} ${php_bin} ${script_libexec_directory}/send_nrdp.php --usestdin --token=\"${nrdp_token}\" --url=${nrdp_protocol}://${nrdp_username}:${nrdp_password}@${obsessing_host}:${obsessing_port}${nrdp_url_path}"
			else
				# shellcheck disable=SC2154
				job_command="${job_command} ${php_bin} ${script_libexec_directory}/send_nrdp.php --usestdin --token=\"${nrdp_token}\" --url=${nrdp_protocol}://${obsessing_host}:${obsessing_port}${nrdp_url_path}"
			fi
			;;
		nsca)
			job_command="${job_command} ${script_libexec_directory}/send_nsca -H ${obsessing_host} -p ${obsessing_port} -c \"${nsca_config_file}\""
			;;
		*)
			logHandler "Invalid obsessing interface defined in config file: '${script_config_file}', exiting."
			script_exit_code="120"
			exit
			;;
	esac

	logHandler "We build the following job command: '${job_command}'."
}

jobExec()
{
	local rc=

	case "${obsessing_interface:-}" in
		nrdp)
			printf "%s\\n" "${script_job_data[@]}" | eval "${job_command}" > /dev/null 2>&1 | logHandler
			;;
		nsca)
			for data in "${script_job_data[@]}"
			do
				printf "%s\\n\\x17" "${data}"
			done | eval "${job_command}" > /dev/null 2>&1 | logHandler
			;;
	esac

	rc="${PIPESTATUS[1]}"

	return "${rc}"
}

counterHandler()
{
	local rc="${1:-}"

	script_job_counter_total="$((script_job_counter_total + 1))"

	if [ "${rc}" == "0" ]
	then
		script_job_counter_ok="$((script_job_counter_ok + 1))"

		if [ "${job_command_log_ok}" == "1" ]
		then
			logHandler "Command: '${job_command}' was successful."
		fi
	elif [ "${job_timeout_enabled}" == "1" ] && [ "${rc}" == "124" ]
	then
		script_job_counter_timeout="$((script_job_counter_timeout + 1))"

		if [ "${job_command_log_timeout}" == "1" ]
		then
			logHandler "Command: '${job_command}' timed out."
		fi
	else
		script_job_counter_nok="$((script_job_counter_nok + 1))"

		if [ "${job_command_log_nok}" == "1" ]
		then
			logHandler "Command: '${job_command}' was not successful."
		fi
	fi
}

jobHandler()
{
	local rc=

	if [ -z "${script_job_pid_1}" ] && [ -z "${script_job_pid_2}" ]
	then
		jobExec &
		script_job_pid_1="${!}"
	elif [ -n "${script_job_pid_1}" ] && [ -z "${script_job_pid_2}" ]
	then
		jobExec &
		script_job_pid_2="${!}"

		wait ${script_job_pid_1}
		rc="${?}"
		counterHandler "${rc}"
		script_job_pid_1=
	elif [ -z "${script_job_pid_1}" ] && [ -n "${script_job_pid_2}" ]
	then
		jobExec &
		script_job_pid_1="${!}"

		wait ${script_job_pid_2}
		rc="${?}"
		counterHandler "${rc}"
		script_job_pid_2=
	elif [ -n "${script_job_pid_1}" ] && [ -n "${script_job_pid_2}" ]
	then
		wait ${script_job_pid_1}
		rc="${?}"
		counterHandler "${rc}"
		script_job_pid_1=

		wait ${script_job_pid_2}
		rc="${?}"
		counterHandler "${rc}"
		script_job_pid_2=

		jobExec &
		script_job_pid_1="${!}"
	fi
}

dataProcessor()
{
	local rc=
	local job_interval_helper="$((SECONDS + job_exec_interval))"
	local regex="^(host|service)(${job_data_separator})(.+)(${job_data_separator})(.+)(${job_data_separator})(.+)(${job_data_separator})(.+)(${job_data_separator})$"

	while read -u 3 -r
	do
		if [[ "${REPLY}" =~ ${regex} ]]
		then
			case "${BASH_REMATCH[1]}" in
				host)
					script_host_counter="$((script_host_counter + 1))"
					script_job_data+=("${BASH_REMATCH[3]}"$'\t'"${BASH_REMATCH[7]}"$'\t'"${BASH_REMATCH[9]}")
					;;
				service)
					script_service_counter="$((script_service_counter + 1))"
					script_job_data+=("${BASH_REMATCH[3]}"$'\t'"${BASH_REMATCH[5]}"$'\t'"${BASH_REMATCH[7]}"$'\t'"${BASH_REMATCH[9]}")
					;;
			esac
		else
			script_invalid_data_counter="$((script_invalid_data_counter + 1))"

			if [ "${log_invalid_data}" == "1" ]
			then
				logHandler "Invalid dataset received: '${REPLY}'."
			fi

			continue
		fi

		if [ "${job_interval_helper}" -le "${SECONDS}" ]
		then
			jobHandler
			script_job_data=()
			job_interval_helper="$((SECONDS + job_exec_interval))"
		fi
	done
}

_main()
{
	#------
	# Main:
	#------

	checkOptions
	setRequiredVariables
	includeConfig
	getUser
	checkBashVersion
	checkAlreadyRunningInstance
	printStatisticWatchdog &
	script_statistic_watchdog_pid="${!}"
	checkNagiosCheckRequirements
	createNamedPipe
	setProxy
	buildJobCommand

	logHandler "Ready to handle jobs..."

	while true
	do
		dataProcessor
		logHandler "Data processor left in main loop..."
	done
}



#-------
# Start:
#-------

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]
then
	#-----------------------
	# Script info variables:
	#-----------------------

	script_pid="$$"
	script_name="${0##*/}"
	script_version="1.0.3-alpha1"
	script_author="Christian Zettel (ccztux)"
	script_copyright="Copyright © 2017 ${script_author}, all rights reserved"
	script_project_website="https://github.com/ccztux/modpd"
	script_last_modification_date="2017-10-03"
	script_minimal_required_bash_version="3"
	script_license="GNU GPLv3"
	script_description="${script_name} (Monitoring Obsessing Data Processor Daemon)"
	script_another_instance_is_running="0"
	script_bypass_exit_routines="0"
	script_log_requirements_ok="1"
	script_exit_code="255"
	script_statistic_watchdog_pid=
	script_job_pid_1=
	script_job_pid_2=
	script_shutdown_in_progress="0"
	script_host_counter="0"
	script_service_counter="0"
	script_invalid_data_counter="0"
	script_job_counter_total="0"
	script_job_counter_ok="0"
	script_job_counter_nok="0"
	script_job_counter_timeout="0"
	script_job_data=()



	#-----------------
	# Get CLI options:
	#-----------------

	OPTERR="0"

	# shellcheck disable=SC2213
	while getopts ":c:l:hv" OPTION
	do
		case "${OPTION}" in
			h)
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="170"
				exit
				;;
			c)
				script_config_file="${OPTARG}"
				;;
			l)
				script_lock_file="${OPTARG}"
				;;
			v)
				printScriptInfos
				script_bypass_exit_routines="1"
				script_exit_code="171"
				exit
				;;
			\?)
				printf "Invalid option: -%s\\n\\n" "${OPTARG}"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="172"
				exit
				;;
			:)
				printf "Option: -%s requires an argument.\\n\\n" "${OPTARG}"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="173"
				exit
				;;
		esac
	done



	#-------------------------
	# Jump into main function:
	#-------------------------

	_main "${@}"
	exit
else
	logHandler "\\nThis is NOT a bash library. Execute it directly!\\n\\n"
	exit 1
fi
