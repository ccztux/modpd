#!/usr/bin/env bash

#========================================================================================================
#
#  Author:				Christian Zettel (ccztux)
#						2017-05-14
#						http://linuxinside.at
#
#  Copyright:			Copyright Â© 2017 Christian Zettel (ccztux), all rights reserved
#
#  Project website:		https://github.com/ccztux/modpd
#
#  Last Modification:	Christian Zettel (ccztux)
#						2020-02-18
#
#  Version				2.0.1-beta1
#
#  Description:			modpd (Monitoring Obsessing Data Processor Daemon)
#
#  License:				GNU GPLv2
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#========================================================================================================


#--------------------------------
# Print error messages to stderr:
#--------------------------------

eprintf()
{
	printf "%b\\n" "${1}" >&2
}



#-------
# Traps:
#-------

if ! trap 'signalHandler SIGUSR1' SIGUSR1
then
	eprintf "Setting trap for signal: 'SIGUSR1' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGTERM' SIGTERM
then
	eprintf "Setting trap for signal: 'SIGTERM' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGINT' SIGINT
then
	eprintf "Setting trap for signal: 'SIGINT' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGHUP' SIGHUP
then
	eprintf "Setting trap for signal: 'SIGHUP' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGABRT' SIGABRT
then
	eprintf "Setting trap for signal: 'SIGABRT' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler SIGQUIT' SIGQUIT
then
	eprintf "Setting trap for signal: 'SIGQUIT' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler "ERR" "${BASH_SOURCE[${#BASH_SOURCE[@]} - 1]}" "${LINENO}" "${BASH_COMMAND}"' ERR
then
	eprintf "Setting trap for signal: 'ERR' was not successful."
	eprintf "Terminating..."
	exit 247
fi

if ! trap 'signalHandler "EXIT"' EXIT
then
	eprintf "Setting trap for signal: 'EXIT' was not successful."
	eprintf "Terminating..."
	exit 247
fi



#---------------
# signalHandler:
#---------------

signalHandler()
{
	local signal="${1:-}"
	local bash_lineno="${2:-}"
	local bash_command="${3:-}"
	local rc=

	case "${signal}" in
		SIGUSR1)
			if [ "${statistic_enabled}" == "1" ]
			then
				printStatistic
			fi

			resetCounters
			;;
		SIGTERM)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="143"
			exit
			;;
		SIGINT)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="130"
			exit
			;;
		SIGHUP)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for config reload..."
			fi

			reloadConfig
			rc="${?}"

			if [ "${rc}" == "0" ]
			then
				logHandler "Config reload was successful."
			else
				logHandler "Config reload was not successful."
			fi
			;;
		SIGABRT)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="134"
			exit
			;;
		SIGQUIT)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi


			script_exit_code="129"
			exit
			;;
		ERR)
			if [ "${script_shutdown_in_progress}" != "1" ]
			then
				logHandler "Caught: '${signal}', at line number: '${bash_lineno}', command: '${bash_command}'."
			fi

			script_exit_code="1"
			exit
			;;
		EXIT)
			if [ "${script_config_file_included}" -eq "1" ]
			then
				printStatistic

				logHandler "Caught: '${signal}', exiting script..."

				if [ "${script_bypass_exit_routines}" != "1" ]
				then
					if [ "${script_another_instance_is_running}" != "1" ]
					then
						checkNamedPipe
						rc="${?}"

						if [ "${rc}" == "0" ]
						then
							removeNamedPipe
						fi

						checkLock
						rc="${?}"

						if [ "${rc}" == "0" ]
						then
							removeLock
						fi
					fi
				else
					logHandler "We hope you are informed better now. :P This was a lazy job. :)"
				fi

				logHandler "Exitcode: '${script_exit_code}'."
				logHandler "${script_name} was running: '${SECONDS}' seconds."
				logHandler "Bye, bye..."
			fi

			if [ -n "${kill_bin:-}" ]
			then
				if [ "${signal}" != "EXIT" ]
				then
					${kill_bin} -s "${signal}" -- -"${script_pid}"
				else
					script_shutdown_in_progress="1"
					${kill_bin} -s SIGTERM -- -"${script_pid}"
				fi
			fi

			exit ${script_exit_code}
			;;
		*)
			logHandler "Caught: '${signal}' in function: '${FUNCNAME[0]}', but dont know what to do with it..."
			return 1
			;;
	esac
}



#------------------------
# Bash and shell options:
#------------------------

checkShellOption()
{
	local shell_option="${1}"

	if [ -n "${shell_option}" ]
	then
		if [[ "${-}" =~ ^(.*)${shell_option}(.*)$ ]] || [[ "${SHELLOPTS}" =~ ^(.*)${shell_option}(.*)$ ]]
		then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

setShellOption()
{
	local shell_option="${1}"

	if [ -n "${shell_option}" ]
	then
		if [[ "${shell_option}" =~ ^([A-Z]|[a-z])$ ]]
		then
			if set -"${shell_option}" 2>/dev/null
			then
				return 0
			else
				return 1
			fi
		else
			if set -o "${shell_option}" 2>/dev/null
			then
				return 0
			else
				return 1
			fi
		fi
	else
		return 2
	fi
}

checkBashOption()
{
	local bash_option="${1}"

	if [ -n "${bash_option}" ]
	then
		if shopt -q "${bash_option}" 2>/dev/null
		then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

setBashOption()
{
	local bash_option="${1}"

	if [ -n "${bash_option}" ]
	then
		if shopt -s "${bash_option}" 2>/dev/null
		then
			return 0
		else
			return 1
		fi
	else
		return 2
	fi
}

setRequiredShellOptions()
{
	local shell_option=
	local required_shell_options=("noclobber" "nounset" "pipefail" "errtrace")

	for shell_option in "${required_shell_options[@]}"
	do
		if ! checkShellOption "${shell_option}"
		then
			if ! setShellOption "${shell_option}"
			then
				eprintf "Setting required shell option: '${shell_option}' was not successful."
				eprintf "Terminating..."
				exit 245
			fi
		fi
	done
}

setRequiredBashOptions()
{
	local bash_option=
	local required_bash_options=("nullglob")

	for bash_option in "${required_bash_options[@]}"
	do
		if ! checkBashOption "${bash_option}"
		then
			if ! setBashOption "${bash_option}"
			then
				eprintf "Setting required bash option: '${bash_option}' was not successful."
				eprintf "Terminating..."
				exit 246
			fi
		fi
	done
}



#-------------------
# Various Functions:
#-------------------

printUsage()
{
	setRequiredVariables

	printf "Usage: %s OPTIONS\\n\\n" "${script_name}"
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "OPTIONS:\\n"
	printf "   -h\\t\\tShows this help.\\n"
	printf "   -c\\t\\tPath to config file. (Default: %s)\\n" "${script_config_file}"
	printf "   -v\\t\\tShows detailed version information.\\n"
}

printScriptInfos()
{
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Project website:\\t%s\\n" "${script_project_website}"
	printf "License:\\t\\t%s\\n\\n" "${script_license}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "Copyright:\\t\\t%s\\n" "${script_copyright}"
}

printStatistic()
{
	logHandler "- Statistic data - ${script_name} is running: '${SECONDS}' seconds"
	logHandler "- Statistic data - Total processed jobs: '${script_job_counter_total}', successful processed jobs: '${script_job_counter_ok}', unsuccessful processed jobs: '${script_job_counter_nok}', timed out jobs: '${script_job_counter_timeout}'."
	logHandler "- Statistic data - Handled host checks: '${script_host_counter}', handled service checks: '${script_service_counter}', invalid datasets received: '${script_invalid_data_counter}'."
}

resetCounters()
{
	script_job_counter_total="0"
	script_job_counter_ok="0"
	script_job_counter_nok="0"
	script_job_counter_timeout="0"
	script_host_counter="0"
	script_service_counter="0"
	script_invalid_data_counter="0"
}

printStatisticWatchdog()
{
	local statistic_interval_helper="$(( SECONDS + statistic_interval ))"

	while true
	do
		if [ "${statistic_interval_helper}" -le "${SECONDS}" ]
		then
			# shellcheck disable=SC2154
			${kill_bin} -SIGUSR1 "${script_pid}"
			statistic_interval_helper="$(( SECONDS + statistic_interval ))"
		fi

		# shellcheck disable=SC2154
		${sleep_bin} 1
	done
}

checkCliOptions()
{
	if [ "${script_argc}" -eq "0" ]
	then
		printUsage
		script_bypass_exit_routines="1"
		script_exit_code="30"
		exit
	fi
}

setRequiredVariables()
{
	# define base path of modpd
	script_base_path="/usr/local/modpd"

	# path to lock directory
	script_lock_directory="${script_base_path}/var/lock"

	# path to libexec directory
	script_libexec_directory="${script_base_path}/libexec"

	# log directory
	script_log_directory="${script_base_path}/var/log"

	# etc directory
	script_etc_directory="${script_base_path}/etc"

	# default config file
	script_config_file="${script_config_file:=${script_etc_directory}/${script_name}.conf}"

	# lock file
	script_lock_file="${script_lock_directory}/${script_name}.lock"

	# log file
	script_log_file="${script_log_directory}/${script_name}.log"
}

reloadConfig()
{
	local rc=

	if  [ -n "${script_statistic_watchdog_pid}" ]
	then
		${kill_bin} -s SIGTERM "${script_statistic_watchdog_pid}"
	fi

	includeConfig
	rc="${?}"

	printStatisticWatchdog &
	script_statistic_watchdog_pid="${!}"

	if [ "${rc}" == "0" ]
	then
		logHandlerSetConfig
		rc="${?}"

		if [ "${rc}" == "0" ]
		then
			setProxy
			rc="${?}"

			if [ "${rc}" == "0" ]
			then
				buildJobCommand
				rc="${?}"

				if [ "${rc}" == "0" ]
				then
					return 0
				else
					return 1
				fi
			else
				return 2
			fi
		else
			return 3
		fi
	else
		return 4
	fi
}

checkBin()
{
	local binary="${1:-}"
	local _bin=

	if _bin="$(command -v "${binary}" 2>/dev/null)"
	then
		export "${binary//-/_}"_bin="${_bin}"
		return 0
	else
		return 1
	fi
}

checkRequiredBinaries()
{
	local rc=
	local required_binaries=()
	local binaries_not_found=()
	local binaries_not_found_helper=

	if [ "${log_to_syslog}" == "1" ]
	then
		required_binaries+=("logger")
	fi

	if [ "${log_to_journal}" -eq "1" ]
	then
		required_binaries+=("systemd-cat")
	fi

	if [ "${log_to_file}" == "1" ] || [ "${log_to_stdout}" == "1" ]
	then
		if [ "${BASH_VERSINFO[0]}" -ge "4" ] && [ "${BASH_VERSINFO[1]}" -ge "2" ]
		then
			date_bin_printf="1"
			date_bin="printf"
		else
			date_bin_printf="0"
			required_binaries+=("date")
		fi
	else
		date_bin_printf="0"
	fi

	if [ "${job_timeout_enabled}" == "1" ]
	then
		required_binaries+=("timeout")
	fi

	if [ "${obsessing_interface}" == "nrdp" ]
	then
		required_binaries+=("php")
	fi

	required_binaries+=("whoami" "pgrep" "rm" "mkdir" "mkfifo" "kill" "sleep")

	for bin in "${required_binaries[@]}"
	do
		if ! checkBin "${bin}"
		then
			binaries_not_found+=("${bin}")
		fi
	done

	if [ "${#binaries_not_found[@]}" -gt "1" ]
	then
		binaries_not_found_helper="${binaries_not_found[*]}"
		binaries_not_found_helper="${binaries_not_found_helper//\ /\,\ }"

		logHandler "Required binaries: '${binaries_not_found_helper}' not found, exiting."
		script_exit_code="127"
		exit
	elif [ "${#binaries_not_found[@]}" -eq "1" ]
	then
		logHandler "Required binary: '${binaries_not_found[*]}' not found, exiting."
		script_exit_code="127"
		exit
	fi
}

includeConfig()
{
	checkFileParameters "${script_config_file}"

	if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_regular_file_is_not_empty ))" -gt "0" ] && [ "$(( file_permission & b_permission_read ))" -gt "0" ]
	then
		# shellcheck source=/scripts/usr/local/modpd/etc/modpd.conf
		if source "${script_config_file}"
		then
			script_config_file_included="1"
		else
			logHandler "Including config file: '${script_config_file}' was not successful."
			logHandler "Terminating..."

			script_bypass_exit_routines="1"
			script_exit_code="20"
			exit
		fi
	elif [ "$(( file_permission & b_regular_file_exists ))" -eq "0" ]
	then
		logHandler "Config file: '${script_config_file}' does not exist."
		logHandler "Terminating..."

		script_bypass_exit_routines="1"
		script_exit_code="21"
		exit
	elif [ "$(( file_permission & b_regular_file_is_not_empty ))" -eq "0" ]
	then
		logHandler "Config file: '${script_config_file}' exists, but is empty."
		logHandler "Terminating..."

		script_bypass_exit_routines="1"
		script_exit_code="22"
		exit
	elif [ "$(( file_permission & b_permission_read ))" -eq "0" ]
	then
		logHandler "Config file: '${script_config_file}' exists, but it is not readable."
		logHandler "Terminating..."

		script_bypass_exit_routines="1"
		script_exit_code="23"
		exit
	fi
}

calculateFunctionNameLength()
{
	local function=
	local function_names=()
	function_names_max_length="0"
	IFS=$'\n' read -d "" -r -a function_names <<< "$(declare -F)"

	for function in "${function_names[@]//declare -f /}"
	do
		if [ "${#function}" -gt "${function_names_max_length}" ]
		then
			function_names_max_length="${#function}"
		fi
	done
}

logHandlerSetConfig()
{
	log_conf="0"
	b_log_to_file="1"
	b_log_to_stdout="2"
	b_log_to_syslog="4"
	b_log_to_journal="8"
	b_date_bin_available="16"
	b_logger_bin_available="32"
	b_systemd_cat_bin_available="64"

	if [ "${date_bin_printf:-}" -eq "1" ]
	then
		date_cmd_format_prefix="'%("
		date_cmd_format_suffix=")T\\n' -1"
	else
		date_cmd_format_prefix="'+"
		date_cmd_format_suffix="'"
	fi

	if [ "${log_to_file}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_file ))"
	fi

	if [ "${log_to_stdout}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_stdout ))"
	fi

	if [ "${log_to_syslog}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_syslog ))"
	fi

	if [ "${log_to_journal}" -eq "1" ]
	then
		log_conf="$(( log_conf | b_log_to_journal ))"
	fi

	if [ -n "${date_bin:-}" ]
	then
		log_conf="$(( log_conf | b_date_bin_available ))"
	fi

	if [ -n "${logger_bin:-}" ]
	then
		log_conf="$(( log_conf | b_logger_bin_available ))"
	fi

	if [ -n "${systemd_cat_bin:-}" ]
	then
		log_conf="$(( log_conf | b_systemd_cat_bin_available ))"
	fi
}

checkLogDir()
{
	checkFileParameters "${script_log_directory}"

	if [ "$(( file_permission & b_is_directory ))" -gt "0" ] && [ "$(( file_permission & b_permission_read ))" -gt "0" ] && [ "$(( file_permission & b_permission_execute ))" -gt "0" ]
	then
		checkFileParameters "${script_log_file}"

		if [ "$(( file_permission & b_regular_file_exists ))" -gt "0" ] && [ "$(( file_permission & b_permission_write ))" -eq "0" ]
		then
			logHandler "Log file exists but we dont have write permissions, exiting."
			script_bypass_exit_routines="1"
			script_exit_code="10"
			exit
		else
			script_log_requirements_ok="1"
			return 0
		fi
	elif [ "$(( file_permission & b_is_directory ))" -eq "0" ]
	then
		logHandler "Log directory doesnt exist."
		logHandler "Creating log directory..."

		# shellcheck disable=SC2154
		if ${mkdir_bin} -p "${script_log_directory}" 2>&1 | logHandler
		then
			logHandler "Creating log directory was successful."
			script_log_requirements_ok="1"
		else
			logHandler "Creating log directory was not successful."
			script_bypass_exit_routines="1"
			script_exit_code="11"
			exit
		fi
	else
		logHandler "Log directory exists but permissions are not ok, exiting."
		script_bypass_exit_routines="1"
		script_exit_code="12"
		exit
	fi
}

checkLogHandlerRequirements()
{
	if [ "$(( log_conf & b_log_to_stdout ))" -gt "0" ] || [ "$(( log_conf & b_log_to_file ))" -gt "0" ]
	then
		calculateFunctionNameLength
	fi

	if [ "$(( log_conf & b_log_to_file ))" -gt "0" ]
	then
		checkLogDir
	fi

	logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"
	logHandler "We are using config file: '${script_config_file}'."
}

logHandlerStdinHelper()
{
	while read -r
	do
		logHandler "${REPLY}"
	done < "/dev/stdin"
}

logHandler()
{
	local log_message="${1:-}"
	local log_timestamp=
	local calling_function=
	local log_secure_replace_string="[HIDDEN FOR SECURITY]"

	if [ -z "${log_message:-}" ]
	then
		if [ ! -t "0" ]
		then
			logHandlerStdinHelper
		fi
	else
		log_message="${log_message//\`/}"
		log_message="${log_message//${proxy_password:-}/${log_secure_replace_string}}"
		log_message="${log_message//${nrdp_password:-}/${log_secure_replace_string}}"
		log_message="${log_message//${nrdp_token:-}/${log_secure_replace_string}}"

		if [ "${script_log_requirements_ok}" -ne "1" ]
		then
			eprintf "${log_message}"
			return
		fi

		if [ "${FUNCNAME[1]}" != "logHandlerStdinHelper" ]
		then
			calling_function="${FUNCNAME[1]}"
		else
			calling_function="${FUNCNAME[3]}"
		fi

		if [ "$(( log_conf & b_log_to_stdout ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_date_bin_available ))" -gt "0" ]
			then
				if [ -z "${log_timestamp}" ]
				then
					log_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${log_timestamp_format}${date_cmd_format_suffix}")"
				fi

				printf "%s | %6d | %*s | %s\\n" "${log_timestamp}" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}"
			else
				printf "[Date bin not found] | %6d | %*s | %s\\n" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_file ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_date_bin_available ))" -gt "0" ]
			then
				if [ -z "${log_timestamp}" ]
				then
					log_timestamp="$(eval "${date_bin} ${date_cmd_format_prefix}${log_timestamp_format}${date_cmd_format_suffix}")"
				fi

				printf "%s | %6d | %*s | %s\\n" "${log_timestamp}" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}" >>"${script_log_file}"
			else
				printf "[Date bin not found] | %6d | %*s | %s\\n" "${script_pid}" "${function_names_max_length}" "${calling_function}" "${log_message}" >>"${script_log_file}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_syslog ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_logger_bin_available ))" -gt "0" ]
			then
				${logger_bin} -t "${script_name}[${script_pid}]" -- "(${calling_function}) ${log_message}"
			fi
		fi

		if [ "$(( log_conf & b_log_to_journal ))" -gt "0" ]
		then
			if [ "$(( log_conf & b_systemd_cat_bin_available ))" -gt "0" ]
			then
				printf "(%s) %s\\n" "${calling_function}" "${log_message}" | ${systemd_cat_bin} --identifier="${script_name}"
			fi
		fi
	fi
}

checkLock()
{
	local rc=

	logHandler "Check if lock file: '${script_lock_file}' exists and if it is read/writeable..."

	checkFilePermissions "${script_lock_file}"
	rc="${?}"

	case "${rc}" in
		6|7)
			logHandler "Lock file exists and it is read/writeable."
			return 0
			;;
		10)
			logHandler "Lock file doesnt exist."
			return 1
			;;
		*)
			logHandler "Lock file exists, but it is not read/writeable."
			return 2
			;;
	esac
}

setLock()
{
	local rc=

	logHandler "Check if script lock directory: '${script_lock_directory}' exists and permissions to set lock are ok..."

	checkDirectoryPermissions "${script_lock_directory}"
	rc="${?}"

	case "${rc}" in
		3|7)
			logHandler "Script lock directory exists and permissions are ok."
			;;
		10)
			logHandler "Script lock directory doesnt exist."
			logHandler "Creating script lock directory..."

			# shellcheck disable=SC2154
			${mkdir_bin} -p "${script_lock_directory}" 2>&1 | logHandler
			rc="${PIPESTATUS[0]}"

			if [ "${rc}" == "0" ]
			then
				logHandler "Creating script lock directory was successful."
			else
				logHandler "Creating script lock directory was not successful, exiting."
				script_exit_code="50"
				exit
			fi
			;;
		*)
			logHandler "Script lock directory exists, but permissions are not ok, exiting."
			script_exit_code="51"
			exit
			;;
	esac

	logHandler "Setting lock..."

	printf "%s\\n" "${script_pid}" > "${script_lock_file}"
	rc="${?}"

	if [ "${rc}" == "0" ]
	then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful. Maybe another instance has set the lock between checking lock and setting lock."
		script_exit_code="52"
		exit
	fi
}

removeLock()
{
	local rc=

	logHandler "Removing lock..."

	# shellcheck disable=SC2154
	${rm_bin} "${script_lock_file}" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"

	if [ "${rc}" == "0" ]
	then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="60"
		exit
	fi
}

setProxy()
{
	if [ "${proxy_enabled}" == "1" ]
	then
		local proxy=
		local proxy_url=

		logHandler "Using proxy is enabled, building proxy configuration..."

		if [ -n "${proxy_port}" ]
		then
			proxy_url="${proxy_ip}:${proxy_port}"
		else
			proxy_url="${proxy_ip}"
		fi

		if [ -n "${proxy_username}" ] && [ -n "${proxy_password}" ]
		then
			proxy="${proxy_protocol}://${proxy_username}:${proxy_password}@${proxy_url}"
		else
			proxy="${proxy_protocol}://${proxy_url}"
		fi

		export http_proxy="${proxy}"
		export https_proxy="${proxy}"
		export ftp_proxy="${proxy}"
		export socks_proxy="${proxy}"
		export HTTP_PROXY="${proxy}"
		export HTTPS_PROXY="${proxy}"
		export FTP_PROXY="${proxy}"
		export SOCKS_PROXY="${proxy}"

		logHandler "We build the following proxy config: '${proxy}'."
	fi
}

checkFileParameters()
{
	local file="${1:-}"

	file_permission="0"
	b_permission_execute="1"
	b_permission_write="2"
	b_permission_read="4"
	b_regular_file_exists="8"
	b_regular_file_is_not_empty="16"
	b_is_directory="32"
	b_is_named_pipe="64"

	if [ -x "${file}" ]
	then
		file_permission="$(( file_permission | b_permission_execute ))"
	fi

	if [ -w "${file}" ]
	then
		file_permission="$(( file_permission | b_permission_write ))"
	fi

	if [ -r "${file}" ]
	then
		file_permission="$(( file_permission | b_permission_read ))"
	fi

	if [ -f "${file}" ]
	then
		file_permission="$(( file_permission | b_regular_file_exists ))"

		if [ -s "${file}" ]
		then
			file_permission="$(( file_permission | b_regular_file_is_not_empty ))"
		fi
	else
		if [ -d "${file}" ]
		then
			file_permission="$(( file_permission | b_is_directory ))"
		fi

		if [ -p "${file}" ]
		then
			file_permission="$(( file_permission | b_is_named_pipe ))"
		fi
	fi
}

checkNamedPipeExists()
{
	local file="${1:-}"

	if [ -p "${file}" ]
	then
		return 0
	else
		return 1
	fi
}

checkNamedPipePermissions()
{
	# file doesnt exist:	rc=10
	# read allowed:		rc=4|5|6|7
	# write allowed:	rc=2|3|6|7
	# execute allowed:	rc=1|3|5|7
	# read/write allowed:	rc=6|7

	local file="${1:-}"
	local rc=
	local file_permission=

	checkNamedPipeExists "${file}"
	rc="${?}"

	if [ "${rc}" == "0" ]
	then
		if [ -x "${file}" ]
		then
			file_permission="$(( file_permission + 2.0.1-beta11 ))"
		fi

		if [ -w "${file}" ]
		then
			file_permission="$(( file_permission + 2#0010 ))"
		fi

		if [ -r "${file}" ]
		then
			file_permission="$(( file_permission + 2.0.1-beta10 ))"
		fi
	else
		file_permission="$(( 2#1010 ))"
	fi

	return "${file_permission}"
}

checkRegularFileExists()
{
	local file="${1:-}"

	if [ -f "${file}" ]
	then
		return 0
	else
		return 1
	fi
}

checkFilePermissions()
{
	# file doesnt exist:	rc=10
	# read allowed:		rc=4|5|6|7
	# write allowed:	rc=2|3|6|7
	# execute allowed:	rc=1|3|5|7
	# read/write allowed:	rc=6|7

	local file="${1:-}"
	local rc=
	local file_permission=

	checkRegularFileExists "${file}"
	rc="${?}"

	if [ "${rc}" == "0" ]
	then
		if [ -x "${file}" ]
		then
			file_permission="$(( file_permission + 2.0.1-beta11 ))"
		fi

		if [ -w "${file}" ]
		then
			file_permission="$(( file_permission + 2#0010 ))"
		fi

		if [ -r "${file}" ]
		then
			file_permission="$(( file_permission + 2.0.1-beta10 ))"
		fi
	else
		file_permission="$(( 2#1010 ))"
	fi

	return "${file_permission}"
}

checkDirectoryExists()
{
	local directory="${1:-}"

	if [ -d "${directory}" ]
	then
		return 0
	else
		return 1
	fi
}

checkDirectoryPermissions()
{
	# directory doesnt exist:	rc=10
	# read allowed:			rc=4|5|6|7
	# write allowed:		rc=2|3|6|7
	# execute allowed:		rc=1|3|5|7

	local directory="${1:-}"
	local rc=
	local directory_permission=

	checkDirectoryExists "${directory}"
	rc="${?}"

	if [ "${rc}" == "0" ]
	then
		if [ -x "${directory}" ]
		then
			directory_permission="$(( directory_permission + 2.0.1-beta11 ))"
		fi

		if [ -w "${directory}" ]
		then
			directory_permission="$(( directory_permission + 2#0010 ))"
		fi

		if [ -r "${directory}" ]
		then
			directory_permission="$(( directory_permission + 2.0.1-beta10 ))"
		fi
	else
		directory_permission="$(( 2#1010 ))"
	fi

	return "${directory_permission}"
}

checkBashVersion()
{
	logHandler "Checking bash version..."

	if [ -z "${BASH_VERSINFO[0]}" ]
	then
		logHandler "Could not determine bash version, exiting."
		script_exit_code="70"
		exit
	else
		if [ "${BASH_VERSINFO[0]}" -lt "${script_minimal_required_bash_version}" ]
		then
			logHandler "Bash version: '${BASH_VERSINFO[0]}' doesnt meet requirements, terminating."

			script_bypass_exit_routines="1"
			script_exit_code="71"
			exit
		else
			logHandler "Bash version: '${BASH_VERSINFO[0]}' meets requirements."
		fi
	fi
}

getUser()
{
	local script_exec_user=

	logHandler "Get user which starts the script..."

	if [ -n "${SUDO_USER:-}" ]
	then
		script_exec_user="$SUDO_USER"
	else
		# shellcheck disable=SC2154
		script_exec_user="$(${whoami_bin})"
	fi

	logHandler "${script_name} was started as user: '${script_exec_user}'."
}

checkAlreadyRunningInstance()
{
	local rc=
	local session_pids=()
	local running_script_pids=()

	# shellcheck disable=SC2154
	# shellcheck disable=SC2207
	session_pids+=($(${pgrep_bin} -d " " -s "${script_pid}"))
	session_pids+=("${script_pid}")
	# shellcheck disable=SC2154
	# shellcheck disable=SC2207
	running_script_pids+=($(${pgrep_bin} -d " " -f "^(.*)bash(.*)${script_base_path}/bin/${script_name}(.*)$"))

	for running_pid in "${!running_script_pids[@]}"
	do
	   	for session_pid in "${!session_pids[@]}"
		do
			if [ "${running_script_pids[$running_pid]}" == "${session_pids[$session_pid]}" ]
			then
				unset "running_script_pids[$running_pid]"
				break
			fi
		done
	done

	logHandler "Check if another instance of: '${script_name}' is already running..."

	checkLock
	rc="${?}"

	if [ "${rc}" != "0" ] && [ -z "${running_script_pids[*]:-}" ]
	then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif [ "${rc}" == "0" ] && [ -z "${running_script_pids[*]:-}" ]
	then
		logHandler "No other instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."
		logHandler "We try to remove the old, leftover lockfile..."

		removeLock
	elif [ "${rc}" == "0" ] && [ -n "${running_script_pids[*]:-}" ]
	then
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids[*]}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="80"
		exit
	elif [ "${rc}" != "0" ] && [ -n "${running_script_pids[*]:-}" ]
	then
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids[*]}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="81"
		exit
	fi
}

createNamedPipe()
{
	local rc=

	checkNamedPipe
	rc="${?}"

	if [ "${rc}" == "1" ]
	then
		logHandler "Creating named pipe..."

		# shellcheck disable=SC2154
		${mkfifo_bin} "${named_pipe_filename}" 2>&1 | logHandler
		rc="${PIPESTATUS[0]}"

		if [ "${rc}" == "0" ]
		then
			logHandler "Creating named pipe was successful."
		else
			logHandler "Creating named pipe was not successful, exiting."
			script_exit_code="90"
			exit
		fi
	fi

	exec 3<> "${named_pipe_filename}"
}

removeNamedPipe()
{
	local rc=

	logHandler "Remove named pipe..."

	# shellcheck disable=SC2154
	${rm_bin} "${named_pipe_filename}" 2>&1 | logHandler
	rc="${PIPESTATUS[0]}"

	if [ "${rc}" == "0" ]
	then
		logHandler "Removing named pipe was successful."

		exec 3>&-
		exec 3<&-
	else
		logHandler "Removing named pipe was not successful, exiting."
		script_exit_code="100"
		exit
	fi
}

checkNamedPipe()
{
	local rc=

	logHandler "Check if named pipe: '${named_pipe_filename}' exists and if it is read/writeable..."

	checkNamedPipePermissions "${named_pipe_filename}"
	rc="${?}"

	case "${rc}" in
		6|7)
			logHandler "Named pipe exists and it is read/writeable."
			return 0
			;;
		10)
			logHandler "Named pipe doesnt exist."
			return 1
			;;
		*)
			logHandler "Named pipe exists, but it is not read/writeable, exiting."
			script_exit_code="110"
			exit
			;;
	esac
}

buildJobCommand()
{
	logHandler "Building job command..."

	if [ "${job_timeout_enabled}" == "1" ]
	then
		# shellcheck disable=SC2154
		job_command="${timeout_bin} --signal=TERM ${job_timeout}"
	fi

	case "${obsessing_interface:-}" in
		nrdp)
			if [ -n "${nrdp_username}" ] && [ -n "${nrdp_password}" ]
			then
				# shellcheck disable=SC2154
				job_command="${job_command} ${php_bin} ${script_libexec_directory}/send_nrdp.php --usestdin --token=\"${nrdp_token}\" --url=${nrdp_protocol}://${nrdp_username}:${nrdp_password}@${obsessing_host}:${obsessing_port}${nrdp_url_path}"
			else
				# shellcheck disable=SC2154
				job_command="${job_command} ${php_bin} ${script_libexec_directory}/send_nrdp.php --usestdin --token=\"${nrdp_token}\" --url=${nrdp_protocol}://${obsessing_host}:${obsessing_port}${nrdp_url_path}"
			fi
			;;
		nsca)
			job_command="${job_command} ${script_libexec_directory}/send_nsca -H ${obsessing_host} -p ${obsessing_port} -c \"${nsca_config_file}\""
			;;
		*)
			logHandler "Invalid obsessing interface defined in config file: '${script_config_file}', exiting."
			script_exit_code="120"
			exit
			;;
	esac

	logHandler "We build the following job command: '${job_command}'."
}

jobExec()
{
	local rc=

	case "${obsessing_interface:-}" in
		nrdp)
			printf "%s\\n" "${script_job_data[@]}" | eval "${job_command}" > /dev/null 2>&1 | logHandler
			;;
		nsca)
			for data in "${script_job_data[@]}"
			do
				printf "%s\\n\\x17" "${data}"
			done | eval "${job_command}" > /dev/null 2>&1 | logHandler
			;;
	esac

	rc="${PIPESTATUS[1]}"

	return "${rc}"
}

counterHandler()
{
	local rc="${1:-}"

	script_job_counter_total="$(( script_job_counter_total + 1 ))"

	if [ "${rc}" == "0" ]
	then
		script_job_counter_ok="$(( script_job_counter_ok + 1 ))"

		if [ "${job_command_log_ok}" == "1" ]
		then
			logHandler "Command: '${job_command}' was successful."
		fi
	elif [ "${job_timeout_enabled}" == "1" ] && [ "${rc}" == "124" ]
	then
		script_job_counter_timeout="$(( script_job_counter_timeout + 1 ))"

		if [ "${job_command_log_timeout}" == "1" ]
		then
			logHandler "Command: '${job_command}' timed out."
		fi
	else
		script_job_counter_nok="$(( script_job_counter_nok + 1 ))"

		if [ "${job_command_log_nok}" == "1" ]
		then
			logHandler "Command: '${job_command}' was not successful."
		fi
	fi
}

jobHandler()
{
	local rc=

	if [ -z "${script_job_pid_1}" ] && [ -z "${script_job_pid_2}" ]
	then
		jobExec &
		script_job_pid_1="${!}"
	elif [ -n "${script_job_pid_1}" ] && [ -z "${script_job_pid_2}" ]
	then
		jobExec &
		script_job_pid_2="${!}"

		wait ${script_job_pid_1}
		rc="${?}"
		counterHandler "${rc}"
		script_job_pid_1=
	elif [ -z "${script_job_pid_1}" ] && [ -n "${script_job_pid_2}" ]
	then
		jobExec &
		script_job_pid_1="${!}"

		wait ${script_job_pid_2}
		rc="${?}"
		counterHandler "${rc}"
		script_job_pid_2=
	elif [ -n "${script_job_pid_1}" ] && [ -n "${script_job_pid_2}" ]
	then
		wait ${script_job_pid_1}
		rc="${?}"
		counterHandler "${rc}"
		script_job_pid_1=

		wait ${script_job_pid_2}
		rc="${?}"
		counterHandler "${rc}"
		script_job_pid_2=

		jobExec &
		script_job_pid_1="${!}"
	fi
}

dataProcessor()
{
	local job_interval_helper="$(( SECONDS + job_exec_interval ))"
	local regex="^(.+)(${job_data_separator})(.+)(${job_data_separator})(.+)(${job_data_separator})(.+)$"

	while read -u 3 -r
	do
		if [[ "${REPLY}" =~ ${regex} ]]
		then
			if [ "${BASH_REMATCH[3]}" == "NULL" ]
			then
				script_host_counter="$(( script_host_counter + 1 ))"
				script_job_data+=("${BASH_REMATCH[1]}"$'\t'"${BASH_REMATCH[5]}"$'\t'"${BASH_REMATCH[7]}")
			else
				script_service_counter="$(( script_service_counter + 1 ))"
				script_job_data+=("${BASH_REMATCH[1]}"$'\t'"${BASH_REMATCH[3]}"$'\t'"${BASH_REMATCH[5]}"$'\t'"${BASH_REMATCH[7]}")
			fi
		else
			script_invalid_data_counter="$(( script_invalid_data_counter + 1 ))"

			if [ "${log_invalid_data}" == "1" ]
			then
				logHandler "Invalid dataset received: '${REPLY}'."
			fi
		fi

		if [ "${job_interval_helper}" -le "${SECONDS}" ]
		then
			jobHandler
			script_job_data=()
			job_interval_helper="$(( SECONDS + job_exec_interval ))"
		fi
	done
}

_main()
{
	#------
	# Main:
	#------

	checkCliOptions
	setRequiredVariables
	includeConfig
	checkRequiredBinaries
	logHandlerSetConfig
	checkLogHandlerRequirements
	getUser
	checkBashVersion
	checkAlreadyRunningInstance
	printStatisticWatchdog &
	script_statistic_watchdog_pid="${!}"
	createNamedPipe
	setProxy
	buildJobCommand

	logHandler "Ready to handle jobs..."

	while true
	do
		dataProcessor
		logHandler "Data processor left in main loop..."
	done
}



#-------
# Start:
#-------

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]
then
	#-----------------------
	# Script info variables:
	#-----------------------

	script_pid="${$}"
	script_argc="${#}"
	script_name="${0##*/}"
	script_version="2.0.1-beta1"
	script_author="Christian Zettel (ccztux)"
	script_copyright="Copyright Â© 2017 ${script_author}, all rights reserved"
	script_project_website="https://github.com/ccztux/modpd"
	script_last_modification_date="2020-02-18"
	script_minimal_required_bash_version="3"
	script_license="GNU GPLv2"
	script_description="${script_name} (Monitoring Obsessing Data Processor Daemon)"
	script_another_instance_is_running="0"
	script_bypass_exit_routines="0"
	script_config_file_included="0"
	script_log_requirements_ok="0"
	script_exit_code="255"
	script_statistic_watchdog_pid=
	script_job_pid_1=
	script_job_pid_2=
	script_shutdown_in_progress="0"
	script_host_counter="0"
	script_service_counter="0"
	script_invalid_data_counter="0"
	script_job_counter_total="0"
	script_job_counter_ok="0"
	script_job_counter_nok="0"
	script_job_counter_timeout="0"
	script_job_data=()



	#-----------------
	# Get CLI options:
	#-----------------

	OPTERR="0"

	# shellcheck disable=SC2213
	while getopts ":c:hv" OPTION
	do
		case "${OPTION}" in
			h)
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="170"
				exit
				;;
			c)
				script_config_file="${OPTARG}"
				;;
			v)
				printScriptInfos
				script_bypass_exit_routines="1"
				script_exit_code="171"
				exit
				;;
			\?)
				printf "Invalid option: -%s\\n\\n" "${OPTARG}"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="172"
				exit
				;;
			:)
				printf "Option: -%s requires an argument.\\n\\n" "${OPTARG}"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="173"
				exit
				;;
		esac
	done



	#-------------------------
	# Jump into main function:
	#-------------------------

	_main "${@}"
	exit
else
	logHandler "\\nThis is NOT a bash library. Execute it directly!\\n\\n"
	exit 1
fi
