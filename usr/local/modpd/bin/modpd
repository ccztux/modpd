#!/usr/bin/env bash

#========================================================================================================
#
#  Author:		Christian Zettel (ccztux)
#			2017-05-14
#			http://linuxinside.at
#
#  Copyright:		Copyright © 2017 Christian Zettel (ccztux), all rights reserved
#
#  Project website:	https://github.com/ccztux/modpd
#
#  Last Modification:	Christian Zettel (ccztux)
#			2017-09-23
#
#  Description:		Monitoring Obsessing Data Processor Daemon
#
#  License:		GNU GPLv3
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#========================================================================================================


#--------------
# Bash options:
#--------------

set -o noclobber || { printf "Setting essential bash option: 'noclobber' was not successful, terminating...\\n" ; exit 245 ; }
set -o nounset || { printf "Setting essential bash option: 'nounset' was not successful, terminating...\\n" ; exit 246 ; }
set -o pipefail || { printf "Setting essential bash option: 'pipefail' was not successful, terminating...\\n" ; exit 247 ; }



#-------
# Traps:
#-------

trap 'sigHandler SIGTERM' SIGTERM || { printf "Setting essential trap for signal: 'SIGTERM' was not successful, terminating...\\n" ; exit 248 ; }
trap 'sigHandler SIGINT' SIGINT || { printf "Setting essential trap for signal: 'SIGINT' was not successful, terminating...\\n" ; exit 249 ; }
trap 'sigHandler SIGHUP' SIGHUP || { printf "Setting essential trap for signal: 'SIGHUP' was not successful, terminating...\\n" ; exit 250 ; }
trap 'sigHandler SIGABRT' SIGABRT || { printf "Setting essential trap for signal: 'SIGABRT' was not successful, terminating...\\n" ; exit 251 ; }
trap 'sigHandler SIGQUIT' SIGQUIT || { printf "Setting essential trap for signal: 'SIGQUIT' was not successful, terminating...\\n" ; exit 252 ; }
trap 'sigHandler ERR "${LINENO}" "${BASH_COMMAND}"' ERR || { printf "Setting essential trap for signal: 'ERR' was not successful, terminating...\\n" ; exit 253 ; }
trap 'sigHandler EXIT' EXIT || { printf "Setting essential trap for signal: 'EXIT' was not successful, terminating...\\n" ; exit 254 ; }



#-----------------------
# Script info variables:
#-----------------------

script_pid="${BASHPID}"
script_name="${0##*/}"
script_version="1.0.2-beta1"
script_author="Christian Zettel (ccztux)"
script_copyright="Copyright © 2017 ${script_author}, all rights reserved"
script_project_website="https://github.com/ccztux/modpd"
script_last_modification_date="2017-09-23"
script_license="GNU GPLv3"
script_description="${script_name} (Monitoring Obsessing Data Processor Daemon)"
script_another_instance_is_running="0"
script_bypass_exit_routines="0"
script_exit_code="255"
script_shutdown_in_progress="0"
script_host_counter="0"
script_service_counter="0"
script_invalid_data_counter="0"
script_job_counter_total="0"
script_job_counter_ok="0"
script_job_counter_nok="0"
script_job_counter_timeout="0"
script_job_data=()



#-----------
# Functions:
#-----------

printUsage()
{
	printf "Usage: %s OPTIONS\\n\\n" "${script_name}"
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "OPTIONS:\\n"
	printf "   -h\\t\\tShows this help.\\n"
	printf "   -c\\t\\tConfig file.\\n"
	printf "   -l\\t\\tLock file.\\n"
	printf "   -v\\t\\tShows detailed version information.\\n"
}

printScriptInfos()
{
	printf "Author:\\t\\t\\t%s\\n" "${script_author}"
	printf "Project website:\\t%s\\n" "${script_project_website}"
	printf "License:\\t\\t%s\\n\\n" "${script_license}"
	printf "Last modification:\\t%s\\n" "${script_last_modification_date}"
	printf "Version:\\t\\t%s\\n\\n" "${script_version}"
	printf "Description:\\t\\t%s\\n\\n" "${script_description}"
	printf "Copyright:\\t\\t%s\\n" "${script_copyright}"
}

printStatistic()
{
	logHandler "${script_name} is running: '${SECONDS}' seconds"
	logHandler "Total processed jobs: '${script_job_counter_total}', successful processed jobs: '${script_job_counter_ok}', unsusccessful processed jobs: '${script_job_counter_nok}', timed out jobs: '${script_job_counter_timeout}'."
	logHandler "Handled host checks: '${script_host_counter}', handled service checks: '${script_service_counter}', invalid data received: '${script_invalid_data_counter}'."
}

checkOptions()
{
	if [ -z "${script_config_file:-}" ] ;then
		printf "Missing option: -c\\n\\n"
		printUsage

		script_bypass_exit_routines="1"
		script_exit_code="10"

		exit
	fi
	
	if [ -z "${script_lock_file:-}" ] ;then
		printf "Missing option: -l\\n\\n"
		printUsage

		script_exit_code="11"
		script_bypass_exit_routines="1"

		exit
	fi
}

includeConfig()
{
	local rc=

	checkFilePermissions "${script_config_file}"
	rc="$?"

	case "${rc}" in
		4|5|6|7)
			# shellcheck source=/scripts/usr/local/modpd/etc/modpd.conf
			source "${script_config_file}"
			rc="$?"

			if [ "${rc}" == "0" ] ;then
				return 0
			else
				return 1
			fi
			;;
		10)
			return 2
			;;
		*)
			return 3
			;;
	esac
}

reloadConfig()
{
	local rc=

	includeConfig
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		logHandlerSetConfig
		rc="$?"

		if [ "${rc}" == "0" ] ;then
			setProxy
			rc="$?"

			if [ "${rc}" == "0" ] ;then
				buildJobCommand
				rc="$?"

				if [ "${rc}" == "0" ] ;then
					return 0
				else
					return 1
				fi
			else
				return 2
			fi
		else
			return 3
		fi
	else
		return 4
	fi
}

checkBin()
{
	local binary="${1:-}"
	local _bin=
	local rc=

	_bin="$(which "${binary}" 2>&1)"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		export "${binary}"_bin="${_bin}"
		return 0
	else
		return 1
	fi
}

checkRequiredBinaries()
{
	local rc=
	local required_binaries=()
	local binaries_not_found=()
	local binaries_not_found_helper=

	if [ "${log_to_syslog}" == "1" ] ;then
		required_binaries+=("logger")
	fi

	if ([ "${log_to_file}" == "1" ] || [ "${log_to_stdout}" == "1" ]) ;then
		if ([ "${BASH_VERSINFO[0]}" -ge "4" ] && [ "${BASH_VERSINFO[1]}" -ge "2" ]) ;then
			date_bin_printf="1"
			date_bin="printf"
		else
			required_binaries+=("date")
		fi
	fi

	if [ "${job_timeout_enabled}" == "1" ] ;then
		required_binaries+=("timeout")
	fi

	required_binaries+=("whoami" "pgrep" "rm" "mkdir" "mkfifo" "kill")

	for bin in "${required_binaries[@]}"
	   do
		checkBin "${bin}"
		rc="$?"

		if [ "${rc}" != "0" ] ;then
			binaries_not_found+=("${bin}")
		fi
	   done

	logHandlerSetConfig
	logHandler "${script_name} ${script_version} starting... (PID=${script_pid})"

	if [ "${#binaries_not_found[*]}" -gt "1" ] ;then
		binaries_not_found_helper="${binaries_not_found[*]}"
		binaries_not_found_helper="${binaries_not_found_helper//\ /\,\ }"

		logHandler "Required binaries: '${binaries_not_found_helper}' not found, exiting."
		script_exit_code="127"
		exit
	elif [ "${#binaries_not_found[*]}" -eq "1" ] ;then
		logHandler "Required binary: '${binaries_not_found[*]}' not found, exiting."
		script_exit_code="127"
		exit
	fi
}

logHandlerSetConfig()
{
	log_conf="$((2#0000000))"
	log_file_full_path="${log_directory}${log_filename}"

	if [ "${date_bin_printf:-}" == "1" ] ;then
		date_cmd="${date_bin:-} '%(${log_timestamp_format})T\\n'"
	else
		date_cmd="${date_bin:-} '+${log_timestamp_format}'"
	fi

	if ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "0" ] && [ "${log_to_syslog}" == "0" ]) ;then
		return
	elif ([ "${log_to_file}" == "1" ] && [ "${log_to_stdout}" == "0" ] && [ "${log_to_syslog}" == "0" ]) ;then
		log_conf="$((log_conf + 2#0000001))"
	elif ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "1" ] && [ "${log_to_syslog}" == "0" ]) ;then
		log_conf="$((log_conf + 2#0000010))"
	elif ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "0" ] && [ "${log_to_syslog}" == "1" ]) ;then
		log_conf="$((log_conf + 2#0000011))"
	elif ([ "${log_to_file}" == "1" ] && [ "${log_to_stdout}" == "1" ] && [ "${log_to_syslog}" == "0" ]) ;then
		log_conf="$((log_conf + 2#0000100))"
	elif ([ "${log_to_file}" == "1" ] && [ "${log_to_stdout}" == "0" ] && [ "${log_to_syslog}" == "1" ]) ;then
		log_conf="$((log_conf + 2#0000101))"
	elif ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "1" ] && [ "${log_to_syslog}" == "1" ]) ;then
		log_conf="$((log_conf + 2#0000110))"
	elif ([ "${log_to_file}" == "0" ] && [ "${log_to_stdout}" == "1" ] && [ "${log_to_syslog}" == "1" ]) ;then
		log_conf="$((log_conf + 2#0000111))"
	fi

	if ([ -z "${date_bin:-}" ] && [ -z "${logger_bin:-}" ]) ;then
		log_conf="$((log_conf + 2#0001000))"
	elif ([ ! -z "${date_bin:-}" ] && [ -z "${logger_bin:-}" ]) ;then
		log_conf="$((log_conf + 2#0010000))"
	elif ([ -z "${date_bin:-}" ] && [ ! -z "${logger_bin:-}" ]) ;then
		log_conf="$((log_conf + 2#0100000))"
	elif ([ ! -z "${date_bin:-}" ] && [ ! -z "${logger_bin:-}" ]) ;then
		log_conf="$((log_conf + 2#1000000))"
	fi
}

logHandlerStdinHelper()
{
	while read -r stdin_line
	   do
		logHandler "${stdin_line}"
	   done < "/dev/stdin"
}

logHandler()
{
	local log_message="${1:-}"
	local log_timestamp=

	if [ -z "${log_message:-}" ] ;then
		if [ ! -t "0" ] ;then
			logHandlerStdinHelper
		fi
	else
		log_message="${log_message//\`/}"

		case "${log_conf:-}" in
					8|16|32|64) # log nothing
						return
						;;
					9) # log to file, zero date, zero logger
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					10) # log to stdout, zero date, zero logger
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					11) # log to syslog, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					12) # log to file and stdout, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					13) # log to file and syslog, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					14) # log to stdout and syslog, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					15) # log to file, stdout and syslog, zero date, zero logger
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[Date bin not found] %s: [%s] [Logger bin not found] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					17) # log to file, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					18) # log to stdout, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					19) # log to syslog, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					20) # log to file and stdout, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					21) # log to file and syslog, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					22) # log to stdout and syslog, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					23) # log to file, stdout and syslog, nonzero date, zero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] [Logger bin not found] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[%s] %s: [%s] [Logger bin not found] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					33) # log to file, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					34) # log to stdout, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					35) # log to syslog, zero date, nonzero logger
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
					36) # log to file and stdout, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						;;
					37) # log to file and syslog, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						${logger_bin} -t "${script_name}[${script_pid}]" "[Date bin not found] ${log_message}"
						;;
					38) # log to stdout and syslog, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						${logger_bin} -t "${script_name}[${script_pid}]" "[Date bin not found] ${log_message}"
						;;
					39) # log to file, stdout and syslog, zero date, nonzero logger
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[Date bin not found] %s: [%s] %s\\n" "${script_name}" "${script_pid}" "${log_message}"
						${logger_bin} -t "${script_name}[${script_pid}]" "[Date bin not found] ${log_message}"
						;;
					65) # log to file, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						;;
					66) # log to stdout, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					67) # log to syslog, nonzero date, nonzero logger
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
					68) # log to file and stdout, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						;;
					69) # log to file and syslog, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
					70) # log to stdout and syslog, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
					71) # log to file, stdout and syslog, nonzero date, nonzero logger
						log_timestamp="$(eval "${date_cmd}")"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}" >> "${log_file_full_path}"
						printf "[%s] %s: [%s] %s\\n" "${log_timestamp}" "${script_name}" "${script_pid}" "${log_message}"
						${logger_bin} -t "${script_name}[${script_pid}]" "${log_message}"
						;;
		esac
	fi
}

sigHandler()
{
	local signal="${1:-}"
	local bash_lineno="${2:-}"
	local bash_command="${3:-}"
	local rc=

	case "${signal}" in
		SIGTERM)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="143"
			exit
			;;
		SIGINT)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="130"
			exit
			;;
		SIGHUP)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for config reload..."
			fi

			reloadConfig
			rc="$?"

			if [ "${rc}" == "0" ] ;then
				logHandler "Config reload was successful."
			else
				logHandler "Config reload was not successful."
			fi
			;;
		SIGABRT)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="134"
			exit
			;;
		SIGQUIT)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', preparing for exiting..."
			fi

			script_exit_code="129"
			exit
			;;
		ERR)
			if [ "${script_shutdown_in_progress}" != "1" ] ;then
				logHandler "Caught: '${signal}', at line number: '${bash_lineno}', command: '${bash_command}'." 
			fi

			script_exit_code="1"
			exit
			;;
		EXIT)
			logHandler "Caught: '${signal}', exiting script..."

			if [ "${script_bypass_exit_routines}" != "1" ] ;then
				if [ "${script_another_instance_is_running}" != "1" ] ;then
					checkNamedPipe
					rc="$?"

					if [ "${rc}" == "0" ] ;then
						removeNamedPipe
					fi

					checkLock
					rc="$?"

					if [ "${rc}" == "0" ] ;then
						removeLock
					fi
				fi
			else
				logHandler "We hope you are informed better now. :P This was a lazy job. :)"
			fi

			printStatistic

			logHandler "Exitcode: '${script_exit_code}'."
			logHandler "${script_name} was running: '${SECONDS}' seconds."
			logHandler "Bye, bye..."

			if [ ! -z "${kill_bin:-}" ] ;then
				if [ "${signal}" != "EXIT" ] ;then
					${kill_bin} -s "${signal}" -- -"${script_pid}"
				else
					script_shutdown_in_progress="1"
					${kill_bin} -s "SIGTERM" -- -"${script_pid}"
				fi
			fi

			exit "${script_exit_code}"
			;;
		*)
			logHandler "Caught: '${signal}' in function: '${FUNCNAME[0]}', but dont know what to do with it..."
			return 1
			;;
	esac
}

checkLock()
{
	local rc=

	logHandler "Check if lock file: '${script_lock_file}' exists and if it is read/writeable..."

	checkFilePermissions "${script_lock_file}"
	rc="$?"

	case "${rc}" in
		6|7)
			logHandler "Lock file exists and it is read/writeable."
			return 0
			;;
		10)
			logHandler "Lock file doesnt exist."
			return 1
			;;
		*)
			logHandler "Lock file exists, but it is not read/writeable."
			return 2
			;;
	esac
}

setLock()
{
	local rc=

	logHandler "Check if script lock directory: '${script_lock_directory}' exists and permissions to set lock are ok..."

	checkDirectoryPermissions "${script_lock_directory}"
	rc="$?"

	case "${rc}" in
		3|7)
			logHandler "Script lock directory exists and permissions are ok."
			;;
		10)
			logHandler "Script lock directory doesnt exist."
			logHandler "Creating script lock directory..."

			# shellcheck disable=SC2154
			${mkdir_bin} -p "${script_lock_directory}" 2>&1 | logHandler

			if [ "${PIPESTATUS[0]}" == "0" ] ;then
				logHandler "Creating script lock directory was successful."
			else
				logHandler "Creating script lock directory was not successful, exiting."
				script_exit_code="20"
				exit
			fi
			;;
		*)
			logHandler "Script lock directory exists, but permissions are not ok, exiting."
			script_exit_code="21"
			exit
			;;
	esac

	logHandler "Setting lock..."

	printf "%s\\n" "${script_pid}" > "${script_lock_file}"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		logHandler "Setting lock was successful."
	else
		logHandler "Setting lock was not successful. Maybe another instance has set the lock between checking lock and setting lock."
		script_exit_code="22"
		exit
	fi
}

removeLock()
{
	logHandler "Removing lock..."

	# shellcheck disable=SC2154
	${rm_bin} "${script_lock_file}" 2>&1 | logHandler

	if [ "${PIPESTATUS[0]}" == "0" ] ;then
		logHandler "Removing lock was successful."
	else
		logHandler "Removing lock was not successful."
		script_exit_code="30"
		exit
	fi
}

setProxy()
{
	if [ "${proxy_enabled}" == "1" ] ;then
		local proxy=
		local proxy_url=
		proxy_protocol="${proxy_protocol,,}"

		logHandler "Using proxy is enabled, building proxy configuration..."

		if [ ! -z "${proxy_port}" ] ;then
			proxy_url="${proxy_ip}:${proxy_port}"
		else
			proxy_url="${proxy_ip}"
		fi

		if ([ ! -z "${proxy_username}" ] && [ ! -z "${proxy_password}" ]) ;then
			proxy="${proxy_protocol}://${proxy_username}:${proxy_password}@${proxy_url}"
		else
			proxy="${proxy_protocol}://${proxy_url}"
		fi

		export http_proxy="${proxy}"
		export https_proxy="${proxy}"
		export ftp_proxy="${proxy}"
		export socks_proxy="${proxy}"
		export HTTP_PROXY="${proxy}"
		export HTTPS_PROXY="${proxy}"
		export FTP_PROXY="${proxy}"
		export SOCKS_PROXY="${proxy}"

		#proxy="${proxy//${proxy_password}/[HIDDEN FOR SECURITY]}"

		logHandler "We build the following proxy config: '${proxy}'."
	fi
}

checkNamedPipeExists()
{
	local file="${1:-}"

	if [ -p "${file}" ] ;then
		return 0
	else
		return 1
	fi
}

checkNamedPipePermissions()
{
	# file doesnt exist:	rc=10
	# read allowed:		rc=4|5|6|7
	# write allowed:	rc=2|3|6|7
	# execute allowed:	rc=1|3|5|7
	# read/write allowed:	rc=6|7

	local file="${1:-}"
	local rc=
	local file_permission=

	checkNamedPipeExists "${file}"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		if [ -x "${file}" ] ;then
			file_permission="$((file_permission + 2#0001))"
		fi

		if [ -w "${file}" ] ;then
			file_permission="$((file_permission + 2#0010))"
		fi

		if [ -r "${file}" ] ;then
			file_permission="$((file_permission + 2#0100))"
		fi
	else
		file_permission="$((2#1010))"
	fi

	return "${file_permission}"
}

checkRegularFileExists()
{
	local file="${1:-}"

	if [ -f "${file}" ] ;then
		return 0
	else
		return 1
	fi
}

checkFilePermissions()
{
	# file doesnt exist:	rc=10
	# read allowed:		rc=4|5|6|7
	# write allowed:	rc=2|3|6|7
	# execute allowed:	rc=1|3|5|7
	# read/write allowed:	rc=6|7

	local file="${1:-}"
	local rc=
	local file_permission=

	checkRegularFileExists "${file}"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		if [ -x "${file}" ] ;then
			file_permission="$((file_permission + 2#0001))"
		fi

		if [ -w "${file}" ] ;then
			file_permission="$((file_permission + 2#0010))"
		fi

		if [ -r "${file}" ] ;then
			file_permission="$((file_permission + 2#0100))"
		fi
	else
		file_permission="$((2#1010))"
	fi

	return "${file_permission}"
}

checkDirectoryExists()
{
	local directory="${1:-}"

	if [ -d "${directory}" ] ;then
		return 0
	else
		return 1
	fi
}

checkDirectoryPermissions()
{
	# directory doesnt exist:	rc=10
	# read allowed:			rc=4|5|6|7
	# write allowed:		rc=2|3|6|7
	# execute allowed:		rc=1|3|5|7

	local directory="${1:-}"
	local rc=
	local directory_permission=

	checkDirectoryExists "${directory}"
	rc="$?"

	if [ "${rc}" == "0" ] ;then
		if [ -x "${directory}" ] ;then
			directory_permission="$((directory_permission + 2#0001))"
		fi

		if [ -w "${directory}" ] ;then
			directory_permission="$((directory_permission + 2#0010))"
		fi

		if [ -r "${directory}" ] ;then
			directory_permission="$((directory_permission + 2#0100))"
		fi
	else
		directory_permission="$((2#1010))"
	fi

	return "${directory_permission}"
}

checkBashVersion()
{
	logHandler "Checking bash version..."

	if [ -z "${BASH_VERSINFO[0]}" ] ;then
		logHandler "Could not determine bash version, exiting."
		script_exit_code="40"
		exit
	else
		case "${BASH_VERSINFO[0]}" in
					3|4)
						logHandler "Bash version: '${BASH_VERSINFO[0]}' meets requirements."
						;;
					*)
						logHandler "Bash version: '${BASH_VERSINFO[0]}' doesnt meet requirements, terminating."
						script_exit_code="41"
						exit
						;;
		esac
	fi
}

getUser()
{
	local rc=
	local script_exec_user=

	logHandler "Get user which starts the script..."

	if [ ! -z "${SUDO_USER:-}" ] ;then
		script_exec_user="$SUDO_USER"
	else
		# shellcheck disable=SC2154
		script_exec_user="$(${whoami_bin})"
	fi

	logHandler "${script_name} was started as user: '${script_exec_user}'."
}

checkAlreadyRunningInstance()
{
	local rc=
	local own_session_pids=()
	local running_script_pids=()

	# shellcheck disable=SC2154
	own_session_pids+=("$(${pgrep_bin} -d " " -s "${script_pid}")")
	own_session_pids+=("${script_pid}")
	# shellcheck disable=SC2154
	running_script_pids+=("$(${pgrep_bin} -d " " -f "^(.*)bash(.*)${script_base_path}/bin/${script_name}(.*)$")")

	for running_pid in "${!running_script_pids[@]}"
	   do
	   	for own_session_pid in "${!own_session_pids[@]}"
		   do
			if [ "${running_script_pids[$running_pid]}" == "${own_session_pids[$own_session_pid]}" ] ;then
				unset "running_script_pids[$running_pid]"
				break
			fi
		   done
	   done

	logHandler "Check if another instance of: '${script_name}' is already running..."

	checkLock
	rc="$?"

	if ([ "${rc}" != "0" ] && [ -z "${running_script_pids[*]:-}" ]) ;then
		logHandler "No other instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and no processes are running)."
		setLock
	elif ([ "${rc}" == "0" ] && [ -z "${running_script_pids[*]:-}" ]) ;then
		logHandler "No other instance of: '${script_name}' seems to be running (Lockfile: '${script_lock_file}' exists and no processes are running). Maybe ${script_name} was terminated abnormally."
		logHandler "We try to remove the old, leftover lockfile..."

		removeLock
	elif ([ "${rc}" == "0" ] && [ ! -z "${running_script_pids[*]:-}" ]) ;then
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' exists and the following processes: '${running_script_pids[*]}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="51"
		exit
	elif ([ "${rc}" != "0" ] && [ ! -z "${running_script_pids[*]:-}" ]) ;then
		logHandler "Another instance of: '${script_name}' is currently running (Lockfile: '${script_lock_file}' doesnt exist and the following processes: '${running_script_pids[*]}' are running)."

		script_another_instance_is_running="1"
		script_exit_code="52"
		exit
	fi
}

createNamedPipe()
{
	local rc=

	checkNamedPipe
	rc="$?"

	if [ "${rc}" == "1" ] ;then
		logHandler "Creating named pipe..."

		# shellcheck disable=SC2154
		${mkfifo_bin} "${named_pipe_filename}" 2>&1 | logHandler

		if [ "${PIPESTATUS[0]}" == "0" ] ;then
			logHandler "Creating named pipe was successful."
			exec 3<> "${named_pipe_filename}"
		else
			logHandler "Creating named pipe was not successful, exiting."
			script_exit_code="60"
			exit
		fi
	fi
}

removeNamedPipe()
{
	logHandler "Remove named pipe..."

	# shellcheck disable=SC2154
	${rm_bin} "${named_pipe_filename}" 2>&1 | logHandler

	if [ "${PIPESTATUS[0]}" == "0" ] ;then
		logHandler "Removing named pipe was successful."

		exec 3>&-
		exec 3<&-
	else
		logHandler "Removing named pipe was not successful, exiting."
		script_exit_code="70"
		exit
	fi
}

checkNamedPipe()
{
	local rc=

	logHandler "Check if named pipe: '${named_pipe_filename}' exists and if it is read/writeable..."

	checkNamedPipePermissions "${named_pipe_filename}"
	rc="$?"

	case "${rc}" in
		6|7)
			logHandler "Named pipe exists and it is read/writeable."
			return 0
			;;
		10)
			logHandler "Named pipe doesnt exist."
			return 1
			;;
		*)
			logHandler "Named pipe exists, but it is not read/writeable, exiting."
			script_exit_code="80"
			exit
			;;
	esac
}

buildJobCommand()
{
	obsessing_interface="${obsessing_interface,,}"
	
	logHandler "Building job command..."

	if [ "${job_timeout_enabled}" == "1" ] ;then
		# shellcheck disable=SC2154
		job_command="${timeout_bin} --signal=TERM ${job_timeout}"
	fi

	case "${obsessing_interface:-}" in
				nrdp)
					nrdp_protocol="${nrdp_protocol,,}"

					if ([ ! -z "${nrdp_username}" ] && [ ! -z "${nrdp_password}" ]) ;then
						job_command="${job_command} ${script_libexec_directory}/send_nrdp.php --usestdin --token=\"${nrdp_token}\" --url=${nrdp_protocol}://${nrdp_username}:${nrdp_password}@${obsessing_host}:${obsessing_port}${nrdp_url_path}"
					else
						job_command="${job_command} ${script_libexec_directory}/send_nrdp.php --usestdin --token=\"${nrdp_token}\" --url=${nrdp_protocol}://${obsessing_host}:${obsessing_port}${nrdp_url_path}"
					fi
					;;
				nsca)
					job_command="${job_command} ${script_libexec_directory}/send_nsca -H ${obsessing_host} -p ${obsessing_port} -c \"${nsca_config_file}\""
					;;
				*)
					logHandler "Invalid obsessing interface defined in config file: '${script_config_file}', exiting."
					script_exit_code="90"
					exit
					;;
	esac

	#job_command="${job_command//${nrdp_password}/[HIDDEN FOR SECURITY]}"
	#job_command="${job_command//${nrdp_token}/[HIDDEN FOR SECURITY]}"
	logHandler "We build the following job command: '${job_command}'."
}

jobExec()
{
	local rc=

	printf "%s\\n" "${script_job_data[@]}" | eval "${job_command}" 2>&1 | logHandler
	rc="${PIPESTATUS[1]}"
	
	return ${rc}
}

jobHandler()
{
	local rc=
	local log_status_line_helper="$((SECONDS + log_status_line_interval))"
	local job_interval_helper="$((SECONDS + job_exec_interval))"
	local job_pid=

	while IFS=$'\t' read -u 3 -r -a data
	   do
		if [ "${log_status_line_helper}" -le "${SECONDS}" ] ;then
			printStatistic
			log_status_line_helper="$((SECONDS + log_status_line_interval))"
		fi

		case "${#data[*]}" in
				3)
					script_host_counter="$((script_host_counter + 1))"
					;;
				4)
					script_service_counter="$((script_service_counter + 1))"
					;;
				*)
					script_invalid_data_counter="$((script_invalid_data_counter + 1))"

					if [ "${log_invalid_data}" == "1" ] ;then
						logHandler "Invalid data received: '${data}'"
					fi

					continue
					;;
		esac

		script_job_data+=("${data}")

		if ([ "${job_interval_helper}" -le "${SECONDS}" ] || [ "${#script_job_data[*]}" -eq "${job_max_bulk_size}" ]) ;then
			if [ ! -z "${job_pid}" ] ;then
				wait ${job_pid}
				rc="$?"
		
				script_job_counter_total="$((script_job_counter_total + 1))"

				if [ "${rc}" == "0" ] ;then
					script_job_counter_ok="$((script_job_counter_ok + 1))"

					if [ "${job_command_log_ok}" == "1" ] ;then
						logHandler "Command: '${job_command}' was successful."
					fi
				elif ([ "${job_timeout_enabled}" == "1" ] && [ "${rc}" == "124" ]) ;then
					script_job_counter_timeout="$((script_job_counter_timeout + 1))"

					if [ "${job_command_log_timeout}" == "1" ] ;then
						logHandler "Command: '${job_command}' timed out."
					fi
				else
					script_job_counter_nok="$((script_job_counter_nok + 1))"

					if [ "${job_command_log_service_nok}" == "1" ] ;then
						logHandler "Command: '${job_command}' was not successful."
					fi
				fi
			fi

			job_pid=

			jobExec  &

			job_pid="$!"
			script_job_data=()
			job_interval_helper="$((SECONDS + job_exec_interval))"
		fi
	   done
}



#-------------
# Get options:
#-------------

OPTERR="0"

# shellcheck disable=SC2213
while getopts ":h.c:l:v." OPTION
   do
	case "${OPTION}" in
			h)
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="170"
				exit
				;;
			c)
				script_config_file="${OPTARG}"
				;;
			l)
				script_lock_file="${OPTARG}"
				;;
			v)
				printScriptInfos
				script_bypass_exit_routines="1"
				script_exit_code="171"
				exit
				;;
			\?)
				printf "Invalid option: -%s\\n\\n" "${OPTARG}"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="172"
				exit
				;;
			:)
				printf "Option: -%s requires an argument.\\n\\n" "${OPTARG}"
				printUsage
				script_bypass_exit_routines="1"
				script_exit_code="173"
				exit
				;;
	esac
   done



#-------
# Start:
#-------

checkOptions
includeConfig

case "$?" in
	0)
		checkRequiredBinaries
		;;
	1)
		printf "Including config file: '%s' was not successful, exiting.\\n" "${script_config_file}"
		script_exit_code="90"
		exit
		;;
	2)
		printf "Config file: '%s' does not exist, exiting.\\n" "${script_config_file}"
		script_exit_code="91"
		exit
		;;
	3)
		printf "Config file: '%s' exists, but it is not readable, exiting.\\n" "${script_config_file}"
		script_exit_code="92"
		exit
		;;
	*)
		printf "Something went terribly wrong in line number: '%s', exiting.\\n" "${LINENO}"
		script_exit_code="93"
		exit
		;;
esac



#------
# Main:
#------

getUser
checkBashVersion
checkAlreadyRunningInstance
createNamedPipe
setProxy
buildJobCommand

logHandler "Ready to handle jobs..."

while true
   do
	jobHandler
   done



#-------------------------
# Should never be reached:
#-------------------------

logHandler "Ooops!!! Something went terribly wrong... :( Exiting."
exit
